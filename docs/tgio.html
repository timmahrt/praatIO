<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>praatio.tgio API documentation</title>
<meta name="description" content="Functions for reading/writing/manipulating textgrid files â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>praatio.tgio</code></h1>
</header>
<section id="section-intro">
<p>Functions for reading/writing/manipulating textgrid files.</p>
<p>This file contains the main data structures for representing Textgrid data:
Textgrid, IntervalTier, and PointTier</p>
<p>A Textgrid is a container for multiple annotation tiers.
Tiers can contain
either interval data (IntervalTier) or point data (PointTier).
Tiers in a Textgrid are ordered and must contain a unique name.</p>
<p>openTextgrid() can be used to open a textgrid file.
Textgrid.save() can be used to save a Textgrid object to a file.</p>
<p>see the <strong>examples/</strong> directory for lots of examples using tgio.py</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions for reading/writing/manipulating textgrid files.

This file contains the main data structures for representing Textgrid data:
Textgrid, IntervalTier, and PointTier

A Textgrid is a container for multiple annotation tiers.  Tiers can contain
either interval data (IntervalTier) or point data (PointTier).
Tiers in a Textgrid are ordered and must contain a unique name.

openTextgrid() can be used to open a textgrid file.
Textgrid.save() can be used to save a Textgrid object to a file.

see the **examples/** directory for lots of examples using tgio.py
&#34;&#34;&#34;

import re
import copy
import io
import wave
import json
from collections import namedtuple

from praatio.utilities import utils

INTERVAL_TIER = &#34;IntervalTier&#34;
POINT_TIER = &#34;TextTier&#34;
MIN_INTERVAL_LENGTH = 0.00000001  # Arbitrary threshold

Interval = namedtuple(&#39;Interval&#39;, [&#39;start&#39;, &#39;end&#39;, &#39;label&#39;]) # interval entry
Point = namedtuple(&#39;Point&#39;, [&#39;time&#39;, &#39;label&#39;]) # point entry

TEXTGRID = &#39;textgrid&#39;
JSON = &#39;json&#39;
SUPPORTED_OUTPUT_FORMATS = [TEXTGRID, JSON]


def _isclose(a, b, rel_tol=1e-14, abs_tol=0.0):
    return abs(a - b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)


def _getWavDuration(wavFN):
    &#34;For internal use.  See praatio.audioio.WavQueryObj() for general use.&#34;
    audiofile = wave.open(wavFN, &#34;r&#34;)
    params = audiofile.getparams()
    framerate = params[2]
    nframes = params[3]
    duration = float(nframes) / framerate
    
    return duration


def _removeBlanks(tier):
    entryList = [entry for entry in tier.entryList if entry[-1] != &#34;&#34;]
    return tier.new(entryList=entryList)


def _fillInBlanks(tier, blankLabel=&#34;&#34;, startTime=None, endTime=None):
    &#39;&#39;&#39;
    Fills in the space between intervals with empty space
    
    This is necessary to do when saving to create a well-formed textgrid
    &#39;&#39;&#39;
    if startTime is None:
        startTime = tier.minTimestamp
        
    if endTime is None:
        endTime = tier.maxTimestamp
    
    # Special case: empty textgrid
    if len(tier.entryList) == 0:
        tier.entryList.append((startTime, endTime, blankLabel))
    
    # Create a new entry list
    entryList = tier.entryList[:]
    entry = entryList[0]
    prevEnd = float(entry[1])
    newEntryList = [entry]
    for entry in entryList[1:]:
        newStart = float(entry[0])
        newEnd = float(entry[1])
        
        if prevEnd &lt; newStart:
            newEntryList.append((prevEnd, newStart, blankLabel))
        newEntryList.append(entry)
        
        prevEnd = newEnd
    
    # Special case: If there is a gap at the start of the file
    assert(float(newEntryList[0][0]) &gt;= float(startTime))
    if float(newEntryList[0][0]) &gt; float(startTime):
        newEntryList.insert(0, (startTime, newEntryList[0][0], blankLabel))
    
    # Special case -- if there is a gap at the end of the file
    if endTime is not None:
        assert(float(newEntryList[-1][1]) &lt;= float(endTime))
        if float(newEntryList[-1][1]) &lt; float(endTime):
            newEntryList.append((newEntryList[-1][1], endTime, blankLabel))

    newEntryList.sort()

    return IntervalTier(tier.name, newEntryList,
                        tier.minTimestamp, tier.maxTimestamp)


def _removeUltrashortIntervals(tier, minLength, minTimestamp):
    &#39;&#39;&#39;
    Remove intervals that are very tiny
    
    Doing many small manipulations on intervals can lead to the creation
    of ultrashort intervals (e.g. 1*10^-15 seconds long).  This function
    removes such intervals.
    &#39;&#39;&#39;
    
    # First, remove tiny intervals
    newEntryList = []
    j = 0  # index to newEntryList
    for start, stop, label in tier.entryList:
        
        if stop - start &lt; minLength:
            # Correct ultra-short entries
            if len(newEntryList) &gt; 0:
                lastStart, _, lastLabel = newEntryList[j - 1]
                newEntryList[j - 1] = (lastStart, stop, lastLabel)
        else:
            # Special case: the first entry in oldEntryList was ultra-short
            if len(newEntryList) == 0 and start != minTimestamp:
                newEntryList.append((minTimestamp, stop, label))
            # Normal case
            else:
                newEntryList.append((start, stop, label))
            j += 1
    
    # Next, shift near equivalent tiny boundaries
    # This will link intervals that were connected by an interval
    # that was shorter than minLength
    j = 0
    while j &lt; len(newEntryList) - 1:
        diff = abs(newEntryList[j][1] - newEntryList[j + 1][0])
        if diff &gt; 0 and diff &lt; minLength:
            newEntryList[j] = (newEntryList[j][0],
                               newEntryList[j + 1][0],
                               newEntryList[j][2])
        j += 1

    return tier.new(entryList=newEntryList)

     
def intervalOverlapCheck(interval, cmprInterval, percentThreshold=0,
                         timeThreshold=0, boundaryInclusive=False):
    &#39;&#39;&#39;
    Checks whether two intervals overlap
    
    If percentThreshold is greater than 0, then if the intervals overlap, they
        must overlap by at least this threshold
    
    If timeThreshold is greater than 0, then if the intervals overlap, they
        must overlap by at least this threshold
        
    If boundaryInclusive is true, then two intervals are considered to overlap
        if they share a boundary
    &#39;&#39;&#39;
    
    startTime, endTime = interval[:2]
    cmprStartTime, cmprEndTime = cmprInterval[:2]
    
    overlapTime = max(0, min(endTime, cmprEndTime) -
                      max(startTime, cmprStartTime))
    overlapFlag = overlapTime &gt; 0
    
    # Do they share a boundary?  Only need to check if one boundary ends
    # when another begins (because otherwise, they overlap in other ways)
    boundaryOverlapFlag = False
    if boundaryInclusive:
        boundaryOverlapFlag = (startTime == cmprEndTime or
                               endTime == cmprStartTime)
    
    # Is the overlap over a certain percent?
    percentOverlapFlag = False
    if percentThreshold &gt; 0 and overlapFlag:
        totalTime = max(endTime, cmprEndTime) - min(startTime, cmprStartTime)
        percentOverlap = overlapTime / float(totalTime)
        
        percentOverlapFlag = percentOverlap &gt;= percentThreshold
    
    # Is the overlap more than a certain threshold?
    timeOverlapFlag = False
    if timeThreshold &gt; 0 and overlapFlag:
        timeOverlapFlag = overlapTime &gt; timeThreshold
        
    overlapFlag = (overlapFlag or boundaryOverlapFlag or
                   percentOverlapFlag or timeOverlapFlag)
    
    return overlapFlag


class TextgridCollisionException(Exception):
    
    def __init__(self, tierName, insertInterval, collisionList):
        super(TextgridCollisionException, self).__init__()
        self.tierName = tierName
        self.insertInterval = insertInterval
        self.collisionList = collisionList
        
    def __str__(self):
        dataTuple = (str(self.insertInterval),
                     self.tierName,
                     str(self.collisionList))
        return (&#34;Attempted to insert interval %s into tier %s of textgrid&#34; +
                &#34;but overlapping entries %s already exist&#34; % dataTuple)

    
class TimelessTextgridTierException(Exception):
    
    def __str__(self):
        return &#34;All textgrid tiers much have a min and max duration&#34;


class BadIntervalError(Exception):
    
    def __init__(self, start, stop, label):
        super(BadIntervalError, self).__init__()
        self.start = start
        self.stop = stop
        self.label = label
        
    def __str__(self):
        dataTuple = (self.start, self.stop, self.label)
        return (&#34;Problem with interval--could not create textgrid &#34; +
                &#34;(%s,%s,%s)&#34; % dataTuple)


class BadFormatException(Exception):

    def __init__(self, selectedFormat, validFormatOptions):
        super(BadFormatException, self).__init__()
        self.selectedFormat = selectedFormat
        self.validFormatOptions = validFormatOptions

    def __str__(self):
        dataTuple = (self.selectedFormat, &#34;, &#34;.join(self.validFormatOptions))
        return &#34;Problem with format.  Received %s but format must be one of %s&#34; % dataTuple


class TextgridTier(object):
    
    tierType = None
    entryType = Interval
    
    def __init__(self, name, entryList, minT, maxT,
                 pairedWav=None):
        &#39;&#39;&#39;See PointTier or IntervalTier&#39;&#39;&#39;
        entryList.sort()
        
        self.name = name
        self.entryList = entryList
        self.minTimestamp = minT
        self.maxTimestamp = maxT
    
    def __eq__(self, other):
        isEqual = True
        isEqual &amp;= self.name == other.name
        isEqual &amp;= _isclose(self.minTimestamp, other.minTimestamp)
        isEqual &amp;= _isclose(self.maxTimestamp, other.maxTimestamp)
        isEqual &amp;= len(self.entryList) == len(self.entryList)
        
        if isEqual:
            for selfEntry, otherEntry in zip(self.entryList, other.entryList):
                for selfSubEntry, otherSubEntry in zip(selfEntry, otherEntry):
                    try:
                        isEqual &amp;= _isclose(selfSubEntry, otherSubEntry)
                    except TypeError:
                        isEqual &amp;= selfSubEntry == otherSubEntry
        
        return isEqual
    
    def appendTier(self, tier):
        &#39;&#39;&#39;
        Append a tier to the end of this one.

        This tier&#39;s maxtimestamp will be lengthened by the amount in the passed in tier.
        &#39;&#39;&#39;

        minTime = self.minTimestamp
        if tier.minTimestamp &lt; minTime:
            minTime = tier.minTimestamp
        
        maxTime = self.maxTimestamp + tier.maxTimestamp
        
        appendTier = tier.editTimestamps(self.maxTimestamp,
                                         allowOvershoot=True)
        
        assert(self.tierType == tier.tierType)
        
        entryList = self.entryList + appendTier.entryList
        entryList.sort()
        
        return self.new(self.name,
                        entryList,
                        minTimestamp=minTime,
                        maxTimestamp=maxTime)

    def deleteEntry(self, entry):
        &#39;&#39;&#39;Removes an entry from the entryList&#39;&#39;&#39;
        self.entryList.pop(self.entryList.index(entry))
    
    def find(self, matchLabel, substrMatchFlag=False, usingRE=False):
        &#39;&#39;&#39;
        Returns the index of all intervals that match the given label
        
        substrMatchFlag: if True, match any label containing matchLabel.
                         if False, label must be the same as matchLabel.
        usingRE: if True, matchLabel is interpreted as a regular expression
        &#39;&#39;&#39;
        returnList = []
        if usingRE is True:
            for i, entry in enumerate(self.entryList):
                matchList = re.findall(matchLabel, entry[-1], re.I)
                if matchList != []:
                    returnList.append(i)
        else:
            for i, entry in enumerate(self.entryList):
                if not substrMatchFlag:
                    if entry[-1] == matchLabel:
                        returnList.append(i)
                else:
                    if matchLabel in entry[-1]:
                        returnList.append(i)
        
        return returnList
    
    def getAsText(self):
        &#39;&#39;&#39;Prints each entry in the tier on a separate line w/ timing info&#39;&#39;&#39;
        text = &#34;&#34;
        text += &#39;&#34;%s&#34;\n&#39; % self.tierType
        text += &#39;&#34;%s&#34;\n&#39; % self.name
        text += &#39;%s\n%s\n%s\n&#39; % (numToStr(self.minTimestamp),
                                  numToStr(self.maxTimestamp),
                                  len(self.entryList))
        
        for entry in self.entryList:
            entry = [numToStr(val) for val in entry[:-1]] + [&#39;&#34;%s&#34;&#39; % entry[-1], ]
            try:
                unicode
            except NameError:
                unicodeFunc = str
            else:
                unicodeFunc = unicode
            
            text += &#34;\n&#34;.join([unicodeFunc(val) for val in entry]) + &#34;\n&#34;
            
        return text
    
    def new(self, name=None, entryList=None, minTimestamp=None,
            maxTimestamp=None, pairedWav=None):
        &#39;&#39;&#39;Make a new tier derived from the current one&#39;&#39;&#39;
        if name is None:
            name = self.name
        if entryList is None:
            entryList = copy.deepcopy(self.entryList)
            entryList = [self.entryType(*entry) if isinstance(entry, tuple)
                         else entry
                         for entry in entryList]
        if minTimestamp is None:
            minTimestamp = self.minTimestamp
        if maxTimestamp is None and pairedWav is None:
            maxTimestamp = self.maxTimestamp
        return type(self)(name, entryList, minTimestamp, maxTimestamp,
                          pairedWav)
    
    def sort(self):
        &#39;&#39;&#39;Sorts the entries in the entryList&#39;&#39;&#39;
        # A list containing tuples and lists will be sorted with tuples
        # first and then lists.  To correctly sort, we need to make
        # sure that all data structures inside the entry list are
        # of the same data type.  The entry list is sorted whenever
        # the entry list is modified, so this is probably the best
        # place to enforce the data type
        self.entryList = [entry if isinstance(entry, self.entryType) else
                          self.entryType(*entry) for entry in self.entryList]
        self.entryList.sort()
        
    def union(self, tier):
        &#39;&#39;&#39;
        The given tier is set unioned to this tier.
        
        All entries in the given tier are added to the current tier.
        Overlapping entries are merged.
        &#39;&#39;&#39;
        retTier = self.new()
        
        for entry in tier.entryList:
            retTier.insertEntry(entry, False, collisionCode=&#39;merge&#39;)
        
        retTier.sort()
        
        return retTier
        

class PointTier(TextgridTier):
    
    tierType = POINT_TIER
    entryType = Point
    
    def __init__(self, name, entryList, minT=None, maxT=None,
                 pairedWav=None):
        &#39;&#39;&#39;
        A point tier is for annotating instaneous events
        
        The entryList is of the form:
        [(timeVal1, label1), (timeVal2, label2), ]
        
        The data stored in the labels can be anything but will
        be interpreted as text by praatio (the label could be descriptive
        text e.g. (&#39;peak point here&#39;) or numerical data e.g. (pitch values
        like &#39;132&#39;))
        &#39;&#39;&#39;
        
        entryList = [Point(float(time), label) for time, label in entryList]
        
        # Determine the min and max timestamps
        timeList = [time for time, label in entryList]
        if minT is not None:
            timeList.append(float(minT))
        if maxT is not None:
            timeList.append(float(maxT))
            
        if maxT is None and pairedWav is not None:
            maxT = _getWavDuration(pairedWav)
        
        try:
            minT = min(timeList)
            maxT = max(timeList)
        except ValueError:
            raise TimelessTextgridTierException()

        super(PointTier, self).__init__(name, entryList, minT, maxT)

    def crop(self, cropStart, cropEnd, mode=None,
             rebaseToZero=True):
        &#39;&#39;&#39;
        Creates a new tier containing all entries inside the new interval
        
        mode is ignored.  This parameter is kept for compatibility with
        IntervalTier.crop()
        &#39;&#39;&#39;
        newEntryList = []
        
        for entry in self.entryList:
            timestamp = entry[0]
            
            if timestamp &gt;= cropStart and timestamp &lt;= cropEnd:
                newEntryList.append(entry)

        if rebaseToZero is True:
            newEntryList = [(timeV - cropStart, label)
                            for timeV, label in newEntryList]
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd

        # Create subtier
        subTier = PointTier(self.name, newEntryList, minT, maxT)
        return subTier

    def editTimestamps(self, offset, allowOvershoot=False):
        &#39;&#39;&#39;
        Modifies all timestamps by a constant amount
        
        If allowOvershoot is True, an interval can go beyond the bounds
        of the textgrid
        &#39;&#39;&#39;
        
        newEntryList = []
        for timestamp, label in self.entryList:
            
            newTimestamp = timestamp + offset
            if not allowOvershoot:
                assert(newTimestamp &gt; self.minTimestamp)
                assert(newTimestamp &lt;= self.maxTimestamp)
            
            if newTimestamp &lt; 0:
                continue
            
            newEntryList.append((newTimestamp, label))
        
        # Determine new min and max timestamps
        timeList = [float(subList[0]) for subList in newEntryList]
        newMin = min(timeList)
        newMax = max(timeList)
        
        if newMin &gt; self.minTimestamp:
            newMin = self.minTimestamp
        
        if newMax &lt; self.maxTimestamp:
            newMax = self.maxTimestamp
        
        return PointTier(self.name, newEntryList, newMin, newMax)
    
    def getValuesAtPoints(self, dataTupleList, fuzzyMatching=False):
        &#39;&#39;&#39;
        Get the values that occur at points in the point tier
        
        If fuzzyMatching is True, if there is not a feature value
        at a point, the nearest feature value will be taken.
        
        The procedure assumes that all data is ordered in time.
        dataTupleList should be in the form
        [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]
        
        The procedure makes one pass through dataTupleList and one
        pass through self.entryList.  If the data is not sequentially
        ordered, the incorrect response will be returned.
        &#39;&#39;&#39;
        
        i = 0
        retList = []
        
        sortedDataTupleList = dataTupleList.sorted()
        for timestamp, label in self.entryList:
            retTuple = utils.getValueAtTime(timestamp,
                                            sortedDataTupleList,
                                            fuzzyMatching=fuzzyMatching,
                                            startI=i)
            retTime, retVal, i = retTuple
            retList.append((retTime, label, retVal))
    
        return retList
        
    def eraseRegion(self, start, stop, collisionCode=None, doShrink=True):
        &#39;&#39;&#39;
        Makes a region in a tier blank (removes all contained entries)
        
        collisionCode: Ignored for the moment (added for compatibility
                       with eraseRegion() for Interval Tiers)
        doShrink: if True, moves leftward by (/stop/ - /start/)
                  all points to the right of /stop/
        &#39;&#39;&#39;

        newTier = self.new()
        croppedTier = newTier.crop(start, stop, &#34;truncated&#34;, False)
        matchList = croppedTier.entryList
        
        if len(matchList) == 0:
            pass
        else:
            
            # Remove all the matches from the entryList
            # Go in reverse order because we&#39;re destructively altering
            # the order of the list (messes up index order)
            for tmpEntry in matchList[::-1]:
                newTier.deleteEntry(tmpEntry)
                
        if doShrink is True:
            newEntryList = []
            diff = stop - start
            for timestamp, label in newTier.entryList:
                if timestamp &lt; start:
                    newEntryList.append((timestamp, label))
                elif timestamp &gt; stop:
                    newEntryList.append((timestamp - diff, label))
            
            newMax = newTier.maxTimestamp - diff
            newTier = newTier.new(entryList=newEntryList,
                                  maxTimestamp=newMax)
                    
        return newTier
                
    def insertEntry(self, entry, warnFlag=True, collisionCode=None):
        &#39;&#39;&#39;
        inserts an interval into the tier
        
        collisionCode: in the event that intervals exist in the insertion area,
                        one of three things may happen
        - &#39;replace&#39; - existing items will be removed
        - &#39;merge&#39; - inserting item will be fused with existing items
        - None or any other value - TextgridCollisionException is thrown
        
        if warnFlag is True and collisionCode is not None,
        the user is notified of each collision
        &#39;&#39;&#39;
        timestamp, label = entry
        
        if not isinstance(entry, Point):
            entry = Point(timestamp, label)
        
        matchList = []
        i = None
        for i, searchEntry in self.entryList:
            if searchEntry[0] == entry[0]:
                matchList.append(searchEntry)
                break
        
        if len(matchList) == 0:
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;replace&#34;:
            self.deleteEntry(self.entryList[i])
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;merge&#34;:
            oldEntry = self.entryList[i]
            newEntry = Point(timestamp, &#34;-&#34;.join([oldEntry[-1], label]))
            self.deleteEntry(self.entryList[i])
            self.entryList.append(newEntry)
            
        else:
            raise TextgridCollisionException(self.name, entry, matchList)
            
        self.sort()
        
        if len(matchList) != 0 and warnFlag is True:
            fmtStr = &#34;Collision warning for %s with items %s of tier %s&#34;
            print((fmtStr % (str(entry), str(matchList), self.name)))
    
    def insertSpace(self, start, duration, collisionCode=None):
        &#39;&#39;&#39;
        Inserts a region into the tier
        
        collisionCode: Ignored for the moment (added for compatibility
                       with insertSpace() for Interval Tiers)
        &#39;&#39;&#39;
        
        newEntryList = []
        for entry in self.entryList:
            if entry[0] &lt;= start:
                newEntryList.append(entry)
            elif entry[0] &gt; start:
                newEntryList.append((entry[0] + duration, entry[1]))
                
        newTier = self.new(entryList=newEntryList,
                           maxTimestamp=self.maxTimestamp + duration)
        
        return newTier

        
class IntervalTier(TextgridTier):
    
    tierType = INTERVAL_TIER
    entryType = Interval
    
    def __init__(self, name, entryList, minT=None, maxT=None,
                 pairedWav=None):
        &#39;&#39;&#39;
        An interval tier is for annotating events that have duration
        
        The entryList is of the form:
        [(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]
        
        The data stored in the labels can be anything but will
        be interpreted as text by praatio (the label could be descriptive
        text e.g. (&#39;erase this region&#39;) or numerical data e.g. (average pitch
        values like &#39;132&#39;))
        &#39;&#39;&#39;
        entryList = [(float(start), float(stop), label)
                     for start, stop, label in entryList]

        if minT is not None:
            minT = float(minT)
        if maxT is not None:
            maxT = float(maxT)
        
        if maxT is None and pairedWav is not None:
            maxT = _getWavDuration(pairedWav)
        
        # Prevent poorly-formed textgrids from being created
        for entry in entryList:
            if entry[0] &gt;= entry[1]:
                fmtStr = &#34;Anomaly: startTime=%f, stopTime=%f, label=%s&#34;
                print((fmtStr % (entry[0], entry[1], entry[2])))
            assert(entry[0] &lt; entry[1])
        
        # Remove whitespace
        tmpEntryList = []
        for start, stop, label in entryList:
            tmpEntryList.append(Interval(start, stop, label.strip()))
        entryList = tmpEntryList
        
        # Determine the minimum and maximum timestampes
        minTimeList = [subList[0] for subList in entryList]
        maxTimeList = [subList[1] for subList in entryList]
        
        if minT is not None:
            minTimeList.append(minT)
        if maxT is not None:
            maxTimeList.append(maxT)

        try:
            minT = min(minTimeList)
            maxT = max(maxTimeList)
        except ValueError:
            raise TimelessTextgridTierException()
        
        super(IntervalTier, self).__init__(name, entryList, minT, maxT)
        
    def crop(self, cropStart, cropEnd, mode, rebaseToZero):
        &#39;&#39;&#39;
        Creates a new tier with all entries that fit inside the new interval
        
        mode = {&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;}
            If &#39;strict&#39;, only intervals wholly contained by the crop
                interval will be kept
            If &#39;lax&#39;, partially contained intervals will be kept
            If &#39;truncated&#39;, partially contained intervals will be
                truncated to fit within the crop region.
        
        If rebaseToZero is True, the cropped textgrid values will be
            subtracted by the cropStart
        &#39;&#39;&#39;
        
        assert(mode in [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;])
        
        # Debugging variables
        cutTStart = 0
        cutTWithin = 0
        cutTEnd = 0
        firstIntervalKeptProportion = 0
        lastIntervalKeptProportion = 0
        
        newEntryList = []
        for entry in self.entryList:
            matchedEntry = None
            
            intervalStart = entry[0]
            intervalEnd = entry[1]
            intervalLabel = entry[2]
            
            # Don&#39;t need to investigate if the interval is before or after
            # the crop region
            if intervalEnd &lt;= cropStart or intervalStart &gt;= cropEnd:
                continue
            
            # Determine if the current subEntry is wholly contained
            # within the superEntry
            if intervalStart &gt;= cropStart and intervalEnd &lt;= cropEnd:
                matchedEntry = entry
            
            # If it is only partially contained within the superEntry AND
            # inclusion is &#39;lax&#39;, include it anyways
            elif mode == &#39;lax&#39; and (intervalStart &gt;= cropStart or
                                    intervalEnd &lt;= cropEnd):
                matchedEntry = entry
            
            # If not strict, include partial tiers on the edges
            # -- regardless, record how much information was lost
            #        - for strict=True, the total time of the cut interval
            #        - for strict=False, the portion of the interval that lies
            #            outside the new interval

            # The current interval stradles the end of the new interval
            elif intervalStart &gt;= cropStart and intervalEnd &gt; cropEnd:
                cutTEnd = intervalEnd - cropEnd
                lastIntervalKeptProportion = ((cropEnd - intervalStart) /
                                              (intervalEnd - intervalStart))

                if mode == &#34;truncated&#34;:
                    matchedEntry = (intervalStart, cropEnd, intervalLabel)
                    
                else:
                    cutTWithin += cropEnd - cropStart
            
            # The current interval stradles the start of the new interval
            elif intervalStart &lt; cropStart and intervalEnd &lt;= cropEnd:
                cutTStart = cropStart - intervalStart
                firstIntervalKeptProportion = ((intervalEnd - cropStart) /
                                               (intervalEnd - intervalStart))
                if mode == &#34;truncated&#34;:
                    matchedEntry = (cropStart, intervalEnd, intervalLabel)
                else:
                    cutTWithin += cropEnd - cropStart

            # The current interval contains the new interval completely
            elif intervalStart &lt;= cropStart and intervalEnd &gt;= cropEnd:

                if mode == &#34;lax&#34;:
                    matchedEntry = entry
                elif mode == &#34;truncated&#34;:
                    matchedEntry = (cropStart, cropEnd, intervalLabel)
                else:
                    cutTWithin += cropEnd - cropStart
                        
            if matchedEntry is not None:
                newEntryList.append(matchedEntry)

        if rebaseToZero is True:
            newEntryList = [(startT - cropStart, stopT - cropStart, label)
                            for startT, stopT, label in newEntryList]
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd

        # Create subtier
        croppedTier = IntervalTier(self.name, newEntryList, minT, maxT)
        
        # DEBUG info
#         debugInfo = (subTier, cutTStart, cutTWithin, cutTEnd,
#                      firstIntervalKeptProportion, lastIntervalKeptProportion)
    
        return croppedTier
    
    def difference(self, tier):
        &#39;&#39;&#39;
        Takes the set difference of this tier and the given one
        
        Any overlapping portions of entries with entries in this textgrid
        will be removed from the returned tier.
        &#39;&#39;&#39;
        retTier = self.new()
        
        for entry in tier.entryList:
            retTier = retTier.eraseRegion(entry[0],
                                          entry[1],
                                          collisionCode=&#39;truncate&#39;,
                                          doShrink=False)
        
        return retTier

    def editTimestamps(self, offset, allowOvershoot=False):
        &#39;&#39;&#39;
        Modifies all timestamps by a constant amount
        
        Can modify the interval start independent of the interval end
        
        If allowOvershoot is True, an interval can go beyond the bounds
        of the textgrid
        &#39;&#39;&#39;
        
        newEntryList = []
        for start, stop, label in self.entryList:
            
            newStart = offset + start
            newStop = offset + stop
            if allowOvershoot is not True:
                assert(newStart &gt;= self.minTimestamp)
                assert(newStop &lt;= self.maxTimestamp)
            
            if newStop &lt; 0:
                continue
            if newStart &lt; 0:
                newStart = 0
            
            if newStart &lt; 0:
                continue
            
            newEntryList.append((newStart, newStop, label))

        # Determine new min and max timestamps
        newMin = min([entry[0] for entry in newEntryList])
        newMax = max([entry[1] for entry in newEntryList])
        
        if newMin &gt; self.minTimestamp:
            newMin = self.minTimestamp
        
        if newMax &lt; self.maxTimestamp:
            newMax = self.maxTimestamp
        
        return IntervalTier(self.name, newEntryList, newMin, newMax)

    def eraseRegion(self, start, stop, collisionCode=None, doShrink=True):
        &#39;&#39;&#39;
        Makes a region in a tier blank (removes all contained entries)
        
        collisionCode: in the event that intervals exist in the insertion area,
                       one of three things may happen
        - &#39;truncate&#39; - partially contained entries will have the portion
                       removed that overlaps with the target entry
        - &#39;categorical&#39; - all entries that overlap, even partially, with the
                          target entry will be completely removed
        - None or any other value - AssertionError is thrown
        
        doShrink: if True, moves leftward by (/stop/ - /start/) amount,
                  each item that occurs after /stop/
        &#39;&#39;&#39;
        
        matchList = self.crop(start, stop, &#39;lax&#39;, False).entryList
        newTier = self.new()

        # if the collisionCode is not properly set it isn&#39;t clear what to do
        assert(collisionCode in [&#39;truncate&#39;, &#39;categorical&#39;])
        
        if len(matchList) == 0:
            pass
        else:
            # Remove all the matches from the entryList
            # Go in reverse order because we&#39;re destructively altering
            # the order of the list (messes up index order)
            for tmpEntry in matchList[::-1]:
                newTier.deleteEntry(tmpEntry)
            
            # If we&#39;re only truncating, reinsert entries on the left and
            # right edges
            if collisionCode == &#39;truncate&#39;:

                # Check left edge
                if matchList[0][0] &lt; start:
                    newEntry = (matchList[0][0], start, matchList[0][-1])
                    newTier.entryList.append(newEntry)
                    
                # Check right edge
                if matchList[-1][1] &gt; stop:
                    newEntry = (stop, matchList[-1][1], matchList[-1][-1])
                    newTier.entryList.append(newEntry)
        
        if doShrink is True:
            
            diff = stop - start
            newEntryList = []
            for entry in newTier.entryList:
                if entry[1] &lt;= start:
                    newEntryList.append(entry)
                elif entry[0] &gt;= stop:
                    newEntryList.append((entry[0] - diff,
                                         entry[1] - diff,
                                         entry[2]))
            
            # Special case: an interval that spanned the deleted
            # section
            for i in range(0, len(newEntryList) - 1):
                rightEdge = newEntryList[i][1] == start
                leftEdge = newEntryList[i + 1][0] == start
                sameLabel = (newEntryList[i][2] == newEntryList[i + 1][2])
                if rightEdge and leftEdge and sameLabel:
                    newEntry = (newEntryList[i][0],
                                newEntryList[i + 1][1],
                                newEntryList[i][2])
                
                    newEntryList.pop(i + 1)
                    newEntryList.pop(i)
                    newEntryList.insert(i, newEntry)
                    
                    # Only one interval can span the deleted section,
                    # so if we&#39;ve found it, move on
                    break
            
            newMax = newTier.maxTimestamp - diff
            newTier = newTier.new(entryList=newEntryList,
                                  maxTimestamp=newMax)
            
        return newTier
    
    def getValuesInIntervals(self, dataTupleList):
        &#39;&#39;&#39;
        Returns data from dataTupleList contained in labeled intervals
        
        dataTupleList should be of the form:
        [(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]
        &#39;&#39;&#39;
        
        returnList = []
        
        for interval in self.entryList:
            intervalDataList = utils.getValuesInInterval(dataTupleList,
                                                         interval[0],
                                                         interval[1])
            returnList.append((interval, intervalDataList))
        
        return returnList
            
    def getNonEntries(self):
        &#39;&#39;&#39;
        Returns the regions of the textgrid without labels
        
        This can include unlabeled segments and regions marked as silent.
        &#39;&#39;&#39;
        entryList = self.entryList
        invertedEntryList = [(entryList[i][1], entryList[i + 1][0], &#34;&#34;)
                             for i in range(len(entryList) - 1)]
        
        # Remove entries that have no duration (ie lie between two entries
        # that share a border)
        invertedEntryList = [entry for entry in invertedEntryList
                             if entry[0] &lt; entry[1]]
        
        if entryList[0][0] &gt; 0:
            invertedEntryList.insert(0, (0, entryList[0][0], &#34;&#34;))
        
        if entryList[-1][1] &lt; self.maxTimestamp:
            invertedEntryList.append((entryList[-1][1], self.maxTimestamp, &#34;&#34;))
        
        invertedEntryList = [entry if isinstance(entry, Interval)
                             else Interval(*entry)
                             for entry in invertedEntryList]
        
        return invertedEntryList
    
    def insertEntry(self, entry, warnFlag=True, collisionCode=None):
        &#39;&#39;&#39;
        inserts an interval into the tier
        
        collisionCode: in the event that intervals exist in the insertion area,
                        one of three things may happen
        - &#39;replace&#39; - existing items will be removed
        - &#39;merge&#39; - inserting item will be fused with existing items
        - None or any other value - TextgridCollisionException is thrown
        
        if warnFlag is True and collisionCode is not None,
        the user is notified of each collision
        &#39;&#39;&#39;
        startTime, endTime = entry[:2]
        
        matchList = self.crop(startTime, endTime, &#39;lax&#39;, False).entryList
        
        if len(matchList) == 0:
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;replace&#34;:
            for matchEntry in matchList:
                self.deleteEntry(matchEntry)
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;merge&#34;:
            for matchEntry in matchList:
                self.deleteEntry(matchEntry)
            matchList.append(entry)
            matchList.sort()  # By starting time
            
            newEntry = (min([entry[0] for entry in matchList]),
                        max([entry[1] for entry in matchList]),
                        &#34;-&#34;.join([entry[2] for entry in matchList]))
            self.entryList.append(Interval(*newEntry))
            
        else:
            raise TextgridCollisionException(self.name, entry, matchList)
            
        self.sort()
        
        if len(matchList) != 0 and warnFlag is True:
            fmtStr = &#34;Collision warning for %s with items %s of tier %s&#34;
            print((fmtStr % (str(entry), str(matchList), self.name)))
    
    def insertSpace(self, start, duration, collisionCode=None):
        &#39;&#39;&#39;
        Inserts a blank region into the tier
        
        collisionCode: in the event that an interval stradles the
                       starting point
        - &#39;stretch&#39; - stretches the interval by /duration/ amount
        - &#39;split&#39; - splits the interval into two--everything to the
                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds
        - &#39;no change&#39; - leaves the interval as is with no change
        - None or any other value - AssertionError is thrown
        &#39;&#39;&#39;

        # if the collisionCode is not properly set it isn&#39;t clear what to do
        assert(collisionCode in [&#39;stretch&#39;, &#39;split&#39;, &#39;no change&#39;])

        newEntryList = []
        for entry in self.entryList:
            # Entry exists before the insertion point
            if entry[1] &lt;= start:
                newEntryList.append(entry)
            # Entry exists after the insertion point
            elif entry[0] &gt;= start:
                newEntryList.append((entry[0] + duration,
                                     entry[1] + duration,
                                     entry[2]))
            # Entry straddles the insertion point
            elif entry[0] &lt;= start and entry[1] &gt; start:
                if collisionCode == &#39;stretch&#39;:
                    newEntryList.append((entry[0],
                                         entry[1] + duration,
                                         entry[2]))
                elif collisionCode == &#39;split&#39;:
                    # Left side of the split
                    newEntryList.append((entry[0],
                                         start,
                                         entry[2]))
                    # Right side of the split
                    newEntryList.append((start + duration,
                                         start + duration + (entry[1] - start),
                                         entry[2]))
                elif collisionCode == &#39;no change&#39;:
                    newEntryList.append(entry)
        
        newTier = self.new(entryList=newEntryList,
                           maxTimestamp=self.maxTimestamp + duration)
                    
        return newTier
       
    def intersection(self, tier):
        &#39;&#39;&#39;
        Takes the set intersection of this tier and the given one
        
        Only intervals that exist in both tiers will remain in the
        returned tier.  If intervals partially overlap, only the overlapping
        portion will be returned.
        &#39;&#39;&#39;
        retEntryList = []
        for start, stop, label in tier.entryList:
            subTier = self.crop(start, stop, &#34;truncated&#34;, False)
            
            # Combine the labels in the two tiers
            stub = &#34;%s-%%s&#34; % label
            subEntryList = [(subEntry[0], subEntry[1], stub % subEntry[2])
                            for subEntry in subTier.entryList]
            
            retEntryList.extend(subEntryList)
        
        newName = &#34;%s-%s&#34; % (self.name, tier.name)
        
        retTier = self.new(newName, retEntryList)
        
        return retTier

    def morph(self, targetTier, filterFunc=None):
        &#39;&#39;&#39;
        Morphs the duration of segments in this tier to those in another
        
        This preserves the labels and the duration of silence in
        this tier while changing the duration of labeled segments.
        &#39;&#39;&#39;
        cumulativeAdjustAmount = 0
        lastFromEnd = 0
        newEntryList = []
        allPoints = [self.entryList, targetTier.entryList]
        for fromEntry, targetEntry in utils.safeZip(allPoints, True):
            
            fromStart, fromEnd, fromLabel = fromEntry
            targetStart, targetEnd = targetEntry[:2]
            
            # fromStart - lastFromEnd -&gt; was this interval and the
            # last one adjacent?
            toStart = (fromStart - lastFromEnd) + cumulativeAdjustAmount

            currAdjustAmount = (fromEnd - fromStart)
            if filterFunc is None or filterFunc(fromLabel):
                currAdjustAmount = (targetEnd - targetStart)
            
            toEnd = cumulativeAdjustAmount = toStart + currAdjustAmount
            newEntryList.append((toStart, toEnd, fromLabel))
            
            lastFromEnd = fromEnd
            
        newMin = self.minTimestamp
        cumulativeDifference = (newEntryList[-1][1] - self.entryList[-1][1])
        newMax = self.maxTimestamp + cumulativeDifference
            
        return IntervalTier(self.name, newEntryList, newMin, newMax)

        
class Textgrid():
    
    def __init__(self):
        &#39;A container that stores and operates over interval and point tiers&#39;
        self.tierNameList = []  # Preserves the order of the tiers
        self.tierDict = {}
    
        self.minTimestamp = None
        self.maxTimestamp = None
    
    def __eq__(self, other):
        isEqual = True
        isEqual &amp;= _isclose(self.minTimestamp, other.minTimestamp)
        isEqual &amp;= _isclose(self.maxTimestamp, other.maxTimestamp)

        isEqual &amp;= self.tierNameList == other.tierNameList
        if isEqual:
            for tierName in self.tierNameList:
                isEqual &amp;= self.tierDict[tierName] == other.tierDict[tierName]
        
        return isEqual
    
    def addTier(self, tier, tierIndex=None):
        &#39;&#39;&#39;
        Add a tier to this textgrid.

        If tierIndex is specified, insert the tier into the specified position.
        &#39;&#39;&#39;
        
        assert(tier.name not in list(self.tierDict.keys()))

        if tierIndex is None:
            self.tierNameList.append(tier.name)
        else:
            self.tierNameList.insert(tierIndex, tier.name)
            
        self.tierDict[tier.name] = tier
        
        minV = tier.minTimestamp
        if self.minTimestamp is None or minV &lt; self.minTimestamp:
            self.minTimestamp = minV
        
        maxV = tier.maxTimestamp
        if self.maxTimestamp is None or maxV &gt; self.maxTimestamp:
            self.maxTimestamp = maxV
    
    def appendTextgrid(self, tg, onlyMatchingNames=True):
        &#39;&#39;&#39;
        Append one textgrid to the end of this one
        
        if onlyMatchingNames is False, tiers that don&#39;t appear in both
        textgrids will also appear
        &#39;&#39;&#39;
        retTG = Textgrid()
        
        minTime = self.minTimestamp
        maxTime = self.maxTimestamp + tg.maxTimestamp
        
        # Get all tier names.  Ordered first by this textgrid and
        # then by the other textgrid.
        combinedTierNameList = self.tierNameList
        for tierName in tg.tierNameList:
            if tierName not in combinedTierNameList:
                combinedTierNameList.append(tierName)
        
        # Determine the tier names that will be in the final textgrid
        finalTierNameList = []
        if onlyMatchingNames is False:
            finalTierNameList = combinedTierNameList
        else:
            for tierName in combinedTierNameList:
                if tierName in self.tierNameList:
                    if tierName in tg.tierNameList:
                        finalTierNameList.append(tierName)
        
        # Add tiers from this textgrid
        for tierName in self.tierNameList:
            if tierName in finalTierNameList:
                tier = self.tierDict[tierName]
                retTG.addTier(tier)
        
        # Add tiers from the given textgrid
        for tierName in tg.tierNameList:
            if tierName in finalTierNameList:
                appendTier = tg.tierDict[tierName]
                appendTier = appendTier.new(minTimestamp=minTime,
                                            maxTimestamp=maxTime)
                
                appendTier = appendTier.editTimestamps(self.maxTimestamp)
                
                if tierName in retTG.tierNameList:
                    tier = retTG.tierDict[tierName]
                    newEntryList = retTG.tierDict[tierName].entryList
                    newEntryList += appendTier.entryList
                    
                    tier = tier.new(entryList=newEntryList,
                                    minTimestamp=minTime,
                                    maxTimestamp=maxTime)
                    retTG.replaceTier(tierName, tier)
                    
                else:
                    tier = appendTier
                    tier = tier.new(minTimestamp=minTime,
                                    maxTimestamp=maxTime)
                    retTG.addTier(tier)
        
        return retTG

    def crop(self, cropStart, cropEnd, mode, rebaseToZero):
        &#39;&#39;&#39;
        Creates a textgrid where all intervals fit within the crop region
        
        mode = {&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;}
            If &#39;strict&#39;, only intervals wholly contained by the crop
                interval will be kept
            If &#39;lax&#39;, partially contained intervals will be kept
            If &#39;truncated&#39;, partially contained intervals will be
                truncated to fit within the crop region.
            
        If rebaseToZero is True, the cropped textgrid values will be
            subtracted by the cropStart
        &#39;&#39;&#39;
        
        assert(mode in [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;])
        
        newTG = Textgrid()
        
        if rebaseToZero is True:
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd
        newTG.minTimestamp = minT
        newTG.maxTimestamp = maxT
        for tierName in self.tierNameList:
            tier = self.tierDict[tierName]
            newTier = tier.crop(cropStart, cropEnd, mode, rebaseToZero)
            newTG.addTier(newTier)
        
        return newTG
    
    def eraseRegion(self, start, stop, doShrink=True):
        &#39;&#39;&#39;
        Makes a region in a tier blank (removes all contained entries)
        
        If &#39;doShrink&#39; is True, all entries appearing after the erased interval
        will be shifted to fill the void (ie the duration of the textgrid
        will be reduced by start - stop)
        &#39;&#39;&#39;

        diff = stop - start

        maxTimestamp = self.maxTimestamp
        if doShrink is True:
            maxTimestamp -= diff
            
        newTG = Textgrid()
        for name in self.tierNameList:
            tier = self.tierDict[name]
            tier = tier.eraseRegion(start, stop, &#39;truncate&#39;, doShrink)
            newTG.addTier(tier)

        newTG.maxTimestamp = maxTimestamp

        return newTG
            
    def editTimestamps(self, offset, allowOvershoot=False):
        &#39;&#39;&#39;
        Modifies all timestamps by a constant amount
        &#39;&#39;&#39;
        
        tg = Textgrid()
        for tierName in self.tierNameList:
            tier = self.tierDict[tierName]
            if len(tier.entryList) &gt; 0:
                tier = tier.editTimestamps(offset, allowOvershoot)
            
            tg.addTier(tier)
        
        return tg
    
    def insertSpace(self, start, duration, collisionCode=None):
        &#39;&#39;&#39;
        Inserts a blank region into a textgrid
        
        Every item that occurs after /start/ will be pushed back by
        /duration/ seconds
        
        collisionCode: in the event that an interval stradles the
                       starting point
        - &#39;stretch&#39; - stretches the interval by /duration/ amount
        - &#39;split&#39; - splits the interval into two--everything to the
                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds
        - &#39;no change&#39; - leaves the interval as is with no change
        - None or any other value - AssertionError is thrown
        &#39;&#39;&#39;
        
        newTG = Textgrid()
        newTG.minTimestamp = self.minTimestamp
        newTG.maxTimestamp = self.maxTimestamp + duration
        
        for tierName in self.tierNameList:
            tier = self.tierDict[tierName]
            newTier = tier.insertSpace(start, duration, collisionCode)
            newTG.addTier(newTier)
        
        return newTG

    def mergeTiers(self, includeFunc=None,
                   tierList=None, preserveOtherTiers=True):
        &#39;&#39;&#39;
        Combine tiers
        
        /includeFunc/ regulates which intervals to include in the merging
          with all others being tossed (default accepts all)
          
        If /tierList/ is none, combine all tiers.
        &#39;&#39;&#39;
        
        if tierList is None:
            tierList = self.tierNameList
            
        if includeFunc is None:
            includeFunc = lambda entryList: True
           
        # Determine the tiers to merge
        intervalTierNameList = []
        pointTierNameList = []
        for tierName in tierList:
            tier = self.tierDict[tierName]
            if isinstance(tier, IntervalTier):
                intervalTierNameList.append(tierName)
            elif isinstance(tier, PointTier):
                pointTierNameList.append(tierName)
        
        # Merge the interval tiers
        intervalTier = None
        if len(intervalTierNameList) &gt; 0:
            intervalTier = self.tierDict[intervalTierNameList.pop(0)]
        for tierName in intervalTierNameList:
            intervalTier = intervalTier.union(self.tierDict[tierName])

        # Merge the point tiers
        pointTier = None
        if len(pointTierNameList) &gt; 0:
            pointTier = self.tierDict[pointTierNameList.pop(0)]
        for tierName in pointTierNameList:
            pointTier = pointTier.merge(self.tierDict[tierName])
        
        # Create the final textgrid to output
        tg = Textgrid()
        
        if intervalTier is not None:
            tg.addTier(intervalTier)
        
        if pointTier is not None:
            tg.addTier(pointTier)
        
        return tg

    def new(self):
        &#39;&#39;&#39;Returns a copy of this Textgrid&#39;&#39;&#39;
        return copy.deepcopy(self)

    def renameTier(self, oldName, newName):
        oldTier = self.tierDict[oldName]
        tierIndex = self.tierNameList.index(oldName)
        self.removeTier(oldName)
        self.addTier(oldTier.new(newName, oldTier.entryList), tierIndex)
    
    def removeTier(self, name):
        self.tierNameList.pop(self.tierNameList.index(name))
        return self.tierDict.pop(name)

    def replaceTier(self, name, newTier):
        tierIndex = self.tierNameList.index(name)
        self.removeTier(name)
        self.addTier(newTier, tierIndex)

    def save(self, fn, minimumIntervalLength=MIN_INTERVAL_LENGTH, minTimestamp=None, maxTimestamp=None, useShortForm=True, outputFormat=TEXTGRID):
        &#39;&#39;&#39;
        To save the current textgrid

        fn - the fullpath filename of the output
        minimumIntervalLength - any labeled intervals smaller than this will be removed,
            useful for removing ultrashort or fragmented intervals; if None, don&#39;t remove any.
        minTimestamp - the minTimestamp of the saved Textgrid; if None, use whatever is defined
            in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid,
            an exception will be thrown.
        maxTimestamp - the maxTimestamp of the saved Textgrid; if None, use whatever is defined
            in the Textgrid object.  If maxTimestamp is smaller than timestamps in your textgrid,
            an exception will be thrown.
        useShortForm - if True, save the textgrid as a short textgrid. Otherwise, use the
            long-form textgrid format.  For backwards compatibility, is True by default.
            Ignored if format is not &#39;Textgrid&#39;
        format - one of [&#39;textgrid&#39;, &#39;json&#39;]
        &#39;&#39;&#39;

        if outputFormat not in SUPPORTED_OUTPUT_FORMATS:
            raise BadFormatException(outputFormat, SUPPORTED_OUTPUT_FORMATS)

        if outputFormat == TEXTGRID:
            if useShortForm:
                outputTxt = _tgToShortTextForm(
                    self,
                    minimumIntervalLength,
                    minTimestamp,
                    maxTimestamp)
            else:
                outputTxt = _tgToLongTextForm(
                    self,
                    minimumIntervalLength,
                    minTimestamp,
                    maxTimestamp)
        elif outputFormat == JSON:
            outputTxt = _tgToJson(self, minimumIntervalLength, minTimestamp, maxTimestamp)

        with io.open(fn, &#34;w&#34;, encoding=&#34;utf-8&#34;) as fd:
            fd.write(outputTxt)

def _prepTgForSaving(tg, minimumIntervalLength, minTimestamp, maxTimestamp):
    for tier in tg.tierDict.values():
        tier.sort()

    if minTimestamp is None:
        minTimestamp = tg.minTimestamp
    else:
        tg.minTimestamp = minTimestamp

    if maxTimestamp is None:
        maxTimestamp = tg.maxTimestamp
    else:
        tg.maxTimestamp = maxTimestamp

    # Fill in the blank spaces for interval tiers
    for name in tg.tierNameList:
        tier = tg.tierDict[name]
        if isinstance(tier, IntervalTier):
            tier = _fillInBlanks(tier,
                                 &#34;&#34;,
                                 minTimestamp,
                                 maxTimestamp)
            if minimumIntervalLength is not None:
                tier = _removeUltrashortIntervals(tier,
                                                  minimumIntervalLength,
                                                  minTimestamp)
            tg.tierDict[name] = tier
    
    for tier in tg.tierDict.values():
        tier.sort()

    return tg


def _tgToShortTextForm(tg, minimumIntervalLength=MIN_INTERVAL_LENGTH, minTimestamp=None, maxTimestamp=None):
    tg = _prepTgForSaving(tg, minimumIntervalLength, minTimestamp, maxTimestamp)

    # Header
    outputTxt = &#34;&#34;
    outputTxt += &#39;File type = &#34;ooTextFile&#34;\n&#39;
    outputTxt += &#39;Object class = &#34;TextGrid&#34;\n\n&#39;
    outputTxt += &#34;%s\n%s\n&#34; % (numToStr(tg.minTimestamp), numToStr(tg.maxTimestamp))
    outputTxt += &#34;&lt;exists&gt;\n%d\n&#34; % len(tg.tierNameList)
    for tierName in tg.tierNameList:
        outputTxt += tg.tierDict[tierName].getAsText()

    return outputTxt


def _tgToLongTextForm(tg, minimumIntervalLength=MIN_INTERVAL_LENGTH, minTimestamp=None, maxTimestamp=None):
    tg = _prepTgForSaving(tg, minimumIntervalLength, minTimestamp, maxTimestamp)
    outputTxt = &#34;&#34;
    outputTxt += &#39;File type = &#34;ooTextFile&#34;\n&#39;
    outputTxt += &#39;Object class = &#34;TextGrid&#34;\n\n&#39;

    tab = &#34; &#34; * 4

    # Header
    outputTxt += &#34;xmin = %s \n&#34; % numToStr(tg.minTimestamp)
    outputTxt += &#34;xmax = %s \n&#34; % numToStr(tg.maxTimestamp)
    outputTxt += &#34;tiers? &lt;exists&gt; \n&#34;
    outputTxt += &#34;size = %d \n&#34; % len(tg.tierNameList)
    outputTxt += &#34;item []: \n&#34;

    for tierNum, tierName in enumerate(tg.tierNameList):
        tier = tg.tierDict[tierName]
        # Interval header
        outputTxt += tab + &#34;item [%d]:\n&#34; % (tierNum + 1)
        outputTxt += tab * 2 + &#39;class = &#34;%s&#34; \n&#39; % tier.tierType
        outputTxt += tab * 2 + &#39;name = &#34;%s&#34; \n&#39; % tierName
        outputTxt += tab * 2 + &#39;xmin = %s \n&#39; % numToStr(tier.minTimestamp)
        outputTxt += tab * 2 + &#39;xmax = %s \n&#39; % numToStr(tier.maxTimestamp)

        if tier.tierType == INTERVAL_TIER:
            outputTxt += tab * 2 + &#39;intervals: size = %d \n&#39; % len(tier.entryList)
            for intervalNum, entry in enumerate(tier.entryList):
                start, stop, label = entry
                outputTxt += tab * 2 + &#39;intervals [%d]:\n&#39; %  (intervalNum + 1)
                outputTxt += tab * 3 + &#39;xmin = %s \n&#39; % numToStr(start)
                outputTxt += tab * 3 + &#39;xmax = %s \n&#39; % numToStr(stop)
                outputTxt += tab * 3 + &#39;text = &#34;%s&#34; \n&#39; % label
        else:
            outputTxt += tab * 2 + &#39;points: size = %d\n &#39; % len(tier.entryList)
            for pointNum, entry in enumerate(tier.entryList):
                timestamp, label = entry
                outputTxt += tab * 2 + &#39;points [%d]:\n&#39; % (pointNum + 1)
                outputTxt += tab * 3 + &#39;number = %s \n&#39; % numToStr(timestamp)
                outputTxt += tab * 3 + &#39;mark = &#34;%s&#34; \n&#39; % label

    return outputTxt


def _tgToJson(tg, minimumIntervalLength, minTimestamp, maxTimestamp):
    &#39;&#39;&#39;Returns a json representation of a textgrid&#39;&#39;&#39;
    tg = _prepTgForSaving(tg, minimumIntervalLength, minTimestamp, maxTimestamp)
    tgAsDict = _tgToDictionary(tg)
    return json.dumps(tgAsDict, ensure_ascii=False)


def _tgToDictionary(tg):
    tiers = []
    for tierName in tg.tierNameList:
        tier = tg.tierDict[tierName]
        tierDict = {
            &#39;class&#39;: tier.tierType,
            &#39;name&#39;: tierName,
            &#39;xmin&#39;: tier.minTimestamp,
            &#39;xmax&#39;: tier.maxTimestamp,
            &#39;entries&#39;: tier.entryList
        }
        tiers.append(tierDict)

    tgAsDict = {
        &#39;xmin&#39;: tg.minTimestamp,
        &#39;xmax&#39;: tg.maxTimestamp,
        &#39;tiers&#39;: tiers
    }

    return tgAsDict


def _dictionaryToTg(tgAsDict):
    &#39;&#39;&#39;Converts a dictionary representation of a textgrid to a Textgrid&#39;&#39;&#39;
    tg = Textgrid()
    tg.minTimestamp = tgAsDict[&#39;xmin&#39;]
    tg.maxTimestamp = tgAsDict[&#39;xmax&#39;]

    for tierAsDict in tgAsDict[&#39;tiers&#39;]:
        if tierAsDict[&#39;class&#39;] == INTERVAL_TIER:
            klass = IntervalTier
        else:
            klass = PointTier
        tier = klass(
            tierAsDict[&#39;name&#39;],
            tierAsDict[&#39;entries&#39;],
            tierAsDict[&#39;xmin&#39;],
            tierAsDict[&#39;xmax&#39;])
        tg.addTier(tier)

    return tg


def openTextgrid(fnFullPath, readRaw=False, readAsJson=False):
    &#39;&#39;&#39;
    Opens a textgrid for editing

    readRaw: points and intervals with an empty label &#39;&#39; are removed unless readRaw=True
    readAsJson: if True, assume the Textgrid is saved as Json rather than in its native format
    &#39;&#39;&#39;
    try:
        with io.open(fnFullPath, &#34;r&#34;, encoding=&#34;utf-16&#34;) as fd:
            data = fd.read()
    except UnicodeError:
        with io.open(fnFullPath, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fd:
            data = fd.read()

    if readAsJson:
        tgAsDict = json.loads(data)
        textgrid = _dictionaryToTg(tgAsDict)
    else:
        data = data.replace(&#34;\r\n&#34;, &#34;\n&#34;)
        
        caseA = &#34;ooTextFile short&#34; in data
        caseB = &#34;item [&#34; not in data
        if caseA or caseB:
            textgrid = _parseShortTextgrid(data)
        else:
            textgrid = _parseNormalTextgrid(data)
    
    if readRaw == False:
        for tierName in textgrid.tierNameList:
            tier = textgrid.tierDict[tierName]
            tier = _removeBlanks(tier)
            textgrid.replaceTier(tierName, tier)

    return textgrid


def _parseNormalTextgrid(data):
    &#39;&#39;&#39;
    Reads a normal textgrid
    &#39;&#39;&#39;
    newTG = Textgrid()
    
    # Toss textgrid header
    header, data = data.split(&#34;item [&#34;, 1)
    
    headerList = header.split(&#34;\n&#34;)
    tgMin = float(headerList[3].split(&#34;=&#34;)[1].strip())
    tgMax = float(headerList[4].split(&#34;=&#34;)[1].strip())
    
    newTG.minTimestamp = tgMin
    newTG.maxTimestamp = tgMax
    
    # Process each tier individually (will be output to separate folders)
    tierList = data.split(&#34;item [&#34;)[1:]
    for tierTxt in tierList:
        
        hasData = True
        
        if &#39;class = &#34;IntervalTier&#34;&#39; in tierTxt:
            tierType = INTERVAL_TIER
            searchWord = &#34;intervals [&#34;
        else:
            tierType = POINT_TIER
            searchWord = &#34;points [&#34;
        
        # Get tier meta-information
        try:
            header, tierData = tierTxt.split(searchWord, 1)
        except ValueError:
            # A tier with no entries
            if &#34;size = 0&#34; in tierTxt:
                header = tierTxt
                tierData = &#34;&#34;
                hadData = False
            else:
                raise
        tierName = header.split(&#34;name = &#34;)[1].split(&#34;\n&#34;, 1)[0]
        tierStart = header.split(&#34;xmin = &#34;)[1].split(&#34;\n&#34;, 1)[0]
        tierStart = strToIntOrFloat(tierStart)
        tierEnd = header.split(&#34;xmax = &#34;)[1].split(&#34;\n&#34;, 1)[0]
        tierEnd = strToIntOrFloat(tierEnd)
        tierName = tierName.strip()[1:-1]
        
        
        # Get the tier entry list
        tierEntryList = []
        labelI = 0
        if tierType == INTERVAL_TIER:
            while True:
                try:
                    timeStart, timeStartI = _fetchRow(tierData,
                                                      &#34;xmin = &#34;, labelI)
                    timeEnd, timeEndI = _fetchRow(tierData,
                                                  &#34;xmax = &#34;, timeStartI)
                    label, labelI = _fetchRow(tierData, &#34;text =&#34;, timeEndI)
                except (ValueError, IndexError):
                    break
                
                label = label.strip()
                tierEntryList.append((timeStart, timeEnd, label))
            tier = IntervalTier(tierName, tierEntryList, tierStart, tierEnd)
        else:
            while True:
                try:
                    time, timeI = _fetchRow(tierData, &#34;number = &#34;, labelI)
                    label, labelI = _fetchRow(tierData, &#34;mark =&#34;, timeI)
                except (ValueError, IndexError):
                    break
                
                label = label.strip()
                tierEntryList.append((time, label))
            tier = PointTier(tierName, tierEntryList, tierStart, tierEnd)
        
        newTG.addTier(tier)
        
    return newTG


def _parseShortTextgrid(data):
    &#39;&#39;&#39;
    Reads a short textgrid file
    &#39;&#39;&#39;
    newTG = Textgrid()
    
    intervalIndicies = [(i, True)
                        for i in utils.findAll(data, &#39;&#34;IntervalTier&#34;&#39;)]
    pointIndicies = [(i, False) for i in utils.findAll(data, &#39;&#34;TextTier&#34;&#39;)]
    
    indexList = intervalIndicies + pointIndicies
    indexList.append((len(data), None))  # The &#39;end&#39; of the file
    indexList.sort()
    
    tupleList = [(indexList[i][0], indexList[i + 1][0], indexList[i][1])
                 for i in range(len(indexList) - 1)]
    
    # Set the textgrid&#39;s min and max times
    header = data[:tupleList[0][0]]
    headerList = header.split(&#34;\n&#34;)
    tgMin = float(headerList[3].strip())
    tgMax = float(headerList[4].strip())
    
    newTG.minTimestamp = tgMin
    newTG.maxTimestamp = tgMax

    # Load the data for each tier
    for blockStartI, blockEndI, isInterval in tupleList:
        tierData = data[blockStartI:blockEndI]
        
        # First row contains the tier type, which we already know
        metaStartI = _fetchRow(tierData, &#39;&#39;, 0)[1]
        
        # Tier meta-information
        tierName, tierNameEndI = _fetchRow(tierData, &#39;&#39;, metaStartI)
        tierStartTime, tierStartTimeI = _fetchRow(tierData, &#39;&#39;, tierNameEndI)
        tierEndTime, tierEndTimeI = _fetchRow(tierData, &#39;&#39;, tierStartTimeI)
        startTimeI = _fetchRow(tierData, &#39;&#39;, tierEndTimeI)[1]
        
        tierStartTime = strToIntOrFloat(tierStartTime)
        tierEndTime = strToIntOrFloat(tierEndTime)
        
        # Tier entry data
        entryList = []
        if isInterval:
            while True:
                try:
                    startTime, endTimeI = _fetchRow(tierData, &#39;&#39;, startTimeI)
                    endTime, labelI = _fetchRow(tierData, &#39;&#39;, endTimeI)
                    label, startTimeI = _fetchRow(tierData, &#39;&#39;, labelI)
                except (ValueError, IndexError):
                    break
                
                label = label.strip()
                entryList.append((startTime, endTime, label))
                
            newTG.addTier(IntervalTier(tierName, entryList,
                                       tierStartTime, tierEndTime))
            
        else:
            while True:
                try:
                    time, labelI = _fetchRow(tierData, &#39;&#39;, startTimeI)
                    label, startTimeI = _fetchRow(tierData, &#39;&#39;, labelI)
                except (ValueError, IndexError):
                    break
                label = label.strip()
                entryList.append((time, label))
                
            newTG.addTier(PointTier(tierName, entryList,
                                    tierStartTime, tierEndTime))

    return newTG


def numToStr(inputNum):
    if _isclose(inputNum, int(inputNum)):
        retVal = &#34;%d&#34; % inputNum
    else:
        retVal = &#34;%s&#34; % repr(inputNum)
    return retVal


def strToIntOrFloat(inputStr):
    return float(inputStr) if &#39;.&#39; in inputStr else int(inputStr)


def _fetchRow(dataStr, searchStr, index):
    startIndex = dataStr.index(searchStr, index) + len(searchStr)
    endIndex = dataStr.index(&#34;\n&#34;, startIndex)
    
    word = dataStr[startIndex:endIndex]
    word = word.strip()
    if word[0] == &#39;&#34;&#39; and word[-1] == &#39;&#34;&#39;:
        word = word[1:-1]
    word = word.strip()
    
    return word, endIndex + 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="praatio.tgio.intervalOverlapCheck"><code class="name flex">
<span>def <span class="ident">intervalOverlapCheck</span></span>(<span>interval, cmprInterval, percentThreshold=0, timeThreshold=0, boundaryInclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether two intervals overlap</p>
<p>If percentThreshold is greater than 0, then if the intervals overlap, they
must overlap by at least this threshold</p>
<p>If timeThreshold is greater than 0, then if the intervals overlap, they
must overlap by at least this threshold</p>
<p>If boundaryInclusive is true, then two intervals are considered to overlap
if they share a boundary</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intervalOverlapCheck(interval, cmprInterval, percentThreshold=0,
                         timeThreshold=0, boundaryInclusive=False):
    &#39;&#39;&#39;
    Checks whether two intervals overlap
    
    If percentThreshold is greater than 0, then if the intervals overlap, they
        must overlap by at least this threshold
    
    If timeThreshold is greater than 0, then if the intervals overlap, they
        must overlap by at least this threshold
        
    If boundaryInclusive is true, then two intervals are considered to overlap
        if they share a boundary
    &#39;&#39;&#39;
    
    startTime, endTime = interval[:2]
    cmprStartTime, cmprEndTime = cmprInterval[:2]
    
    overlapTime = max(0, min(endTime, cmprEndTime) -
                      max(startTime, cmprStartTime))
    overlapFlag = overlapTime &gt; 0
    
    # Do they share a boundary?  Only need to check if one boundary ends
    # when another begins (because otherwise, they overlap in other ways)
    boundaryOverlapFlag = False
    if boundaryInclusive:
        boundaryOverlapFlag = (startTime == cmprEndTime or
                               endTime == cmprStartTime)
    
    # Is the overlap over a certain percent?
    percentOverlapFlag = False
    if percentThreshold &gt; 0 and overlapFlag:
        totalTime = max(endTime, cmprEndTime) - min(startTime, cmprStartTime)
        percentOverlap = overlapTime / float(totalTime)
        
        percentOverlapFlag = percentOverlap &gt;= percentThreshold
    
    # Is the overlap more than a certain threshold?
    timeOverlapFlag = False
    if timeThreshold &gt; 0 and overlapFlag:
        timeOverlapFlag = overlapTime &gt; timeThreshold
        
    overlapFlag = (overlapFlag or boundaryOverlapFlag or
                   percentOverlapFlag or timeOverlapFlag)
    
    return overlapFlag</code></pre>
</details>
</dd>
<dt id="praatio.tgio.numToStr"><code class="name flex">
<span>def <span class="ident">numToStr</span></span>(<span>inputNum)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numToStr(inputNum):
    if _isclose(inputNum, int(inputNum)):
        retVal = &#34;%d&#34; % inputNum
    else:
        retVal = &#34;%s&#34; % repr(inputNum)
    return retVal</code></pre>
</details>
</dd>
<dt id="praatio.tgio.openTextgrid"><code class="name flex">
<span>def <span class="ident">openTextgrid</span></span>(<span>fnFullPath, readRaw=False, readAsJson=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Opens a textgrid for editing</p>
<p>readRaw: points and intervals with an empty label '' are removed unless readRaw=True
readAsJson: if True, assume the Textgrid is saved as Json rather than in its native format</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openTextgrid(fnFullPath, readRaw=False, readAsJson=False):
    &#39;&#39;&#39;
    Opens a textgrid for editing

    readRaw: points and intervals with an empty label &#39;&#39; are removed unless readRaw=True
    readAsJson: if True, assume the Textgrid is saved as Json rather than in its native format
    &#39;&#39;&#39;
    try:
        with io.open(fnFullPath, &#34;r&#34;, encoding=&#34;utf-16&#34;) as fd:
            data = fd.read()
    except UnicodeError:
        with io.open(fnFullPath, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fd:
            data = fd.read()

    if readAsJson:
        tgAsDict = json.loads(data)
        textgrid = _dictionaryToTg(tgAsDict)
    else:
        data = data.replace(&#34;\r\n&#34;, &#34;\n&#34;)
        
        caseA = &#34;ooTextFile short&#34; in data
        caseB = &#34;item [&#34; not in data
        if caseA or caseB:
            textgrid = _parseShortTextgrid(data)
        else:
            textgrid = _parseNormalTextgrid(data)
    
    if readRaw == False:
        for tierName in textgrid.tierNameList:
            tier = textgrid.tierDict[tierName]
            tier = _removeBlanks(tier)
            textgrid.replaceTier(tierName, tier)

    return textgrid</code></pre>
</details>
</dd>
<dt id="praatio.tgio.strToIntOrFloat"><code class="name flex">
<span>def <span class="ident">strToIntOrFloat</span></span>(<span>inputStr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strToIntOrFloat(inputStr):
    return float(inputStr) if &#39;.&#39; in inputStr else int(inputStr)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="praatio.tgio.BadFormatException"><code class="flex name class">
<span>class <span class="ident">BadFormatException</span></span>
<span>(</span><span>selectedFormat, validFormatOptions)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadFormatException(Exception):

    def __init__(self, selectedFormat, validFormatOptions):
        super(BadFormatException, self).__init__()
        self.selectedFormat = selectedFormat
        self.validFormatOptions = validFormatOptions

    def __str__(self):
        dataTuple = (self.selectedFormat, &#34;, &#34;.join(self.validFormatOptions))
        return &#34;Problem with format.  Received %s but format must be one of %s&#34; % dataTuple</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="praatio.tgio.BadIntervalError"><code class="flex name class">
<span>class <span class="ident">BadIntervalError</span></span>
<span>(</span><span>start, stop, label)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadIntervalError(Exception):
    
    def __init__(self, start, stop, label):
        super(BadIntervalError, self).__init__()
        self.start = start
        self.stop = stop
        self.label = label
        
    def __str__(self):
        dataTuple = (self.start, self.stop, self.label)
        return (&#34;Problem with interval--could not create textgrid &#34; +
                &#34;(%s,%s,%s)&#34; % dataTuple)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="praatio.tgio.Interval"><code class="flex name class">
<span>class <span class="ident">Interval</span></span>
<span>(</span><span>start, end, label)</span>
</code></dt>
<dd>
<section class="desc"><p>Interval(start, end, label)</p></section>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="praatio.tgio.Interval.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="praatio.tgio.Interval.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="praatio.tgio.Interval.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
</dl>
</dd>
<dt id="praatio.tgio.IntervalTier"><code class="flex name class">
<span>class <span class="ident">IntervalTier</span></span>
<span>(</span><span>name, entryList, minT=None, maxT=None, pairedWav=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An interval tier is for annotating events that have duration</p>
<p>The entryList is of the form:
[(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]</p>
<p>The data stored in the labels can be anything but will
be interpreted as text by praatio (the label could be descriptive
text e.g. ('erase this region') or numerical data e.g. (average pitch
values like '132'))</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntervalTier(TextgridTier):
    
    tierType = INTERVAL_TIER
    entryType = Interval
    
    def __init__(self, name, entryList, minT=None, maxT=None,
                 pairedWav=None):
        &#39;&#39;&#39;
        An interval tier is for annotating events that have duration
        
        The entryList is of the form:
        [(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]
        
        The data stored in the labels can be anything but will
        be interpreted as text by praatio (the label could be descriptive
        text e.g. (&#39;erase this region&#39;) or numerical data e.g. (average pitch
        values like &#39;132&#39;))
        &#39;&#39;&#39;
        entryList = [(float(start), float(stop), label)
                     for start, stop, label in entryList]

        if minT is not None:
            minT = float(minT)
        if maxT is not None:
            maxT = float(maxT)
        
        if maxT is None and pairedWav is not None:
            maxT = _getWavDuration(pairedWav)
        
        # Prevent poorly-formed textgrids from being created
        for entry in entryList:
            if entry[0] &gt;= entry[1]:
                fmtStr = &#34;Anomaly: startTime=%f, stopTime=%f, label=%s&#34;
                print((fmtStr % (entry[0], entry[1], entry[2])))
            assert(entry[0] &lt; entry[1])
        
        # Remove whitespace
        tmpEntryList = []
        for start, stop, label in entryList:
            tmpEntryList.append(Interval(start, stop, label.strip()))
        entryList = tmpEntryList
        
        # Determine the minimum and maximum timestampes
        minTimeList = [subList[0] for subList in entryList]
        maxTimeList = [subList[1] for subList in entryList]
        
        if minT is not None:
            minTimeList.append(minT)
        if maxT is not None:
            maxTimeList.append(maxT)

        try:
            minT = min(minTimeList)
            maxT = max(maxTimeList)
        except ValueError:
            raise TimelessTextgridTierException()
        
        super(IntervalTier, self).__init__(name, entryList, minT, maxT)
        
    def crop(self, cropStart, cropEnd, mode, rebaseToZero):
        &#39;&#39;&#39;
        Creates a new tier with all entries that fit inside the new interval
        
        mode = {&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;}
            If &#39;strict&#39;, only intervals wholly contained by the crop
                interval will be kept
            If &#39;lax&#39;, partially contained intervals will be kept
            If &#39;truncated&#39;, partially contained intervals will be
                truncated to fit within the crop region.
        
        If rebaseToZero is True, the cropped textgrid values will be
            subtracted by the cropStart
        &#39;&#39;&#39;
        
        assert(mode in [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;])
        
        # Debugging variables
        cutTStart = 0
        cutTWithin = 0
        cutTEnd = 0
        firstIntervalKeptProportion = 0
        lastIntervalKeptProportion = 0
        
        newEntryList = []
        for entry in self.entryList:
            matchedEntry = None
            
            intervalStart = entry[0]
            intervalEnd = entry[1]
            intervalLabel = entry[2]
            
            # Don&#39;t need to investigate if the interval is before or after
            # the crop region
            if intervalEnd &lt;= cropStart or intervalStart &gt;= cropEnd:
                continue
            
            # Determine if the current subEntry is wholly contained
            # within the superEntry
            if intervalStart &gt;= cropStart and intervalEnd &lt;= cropEnd:
                matchedEntry = entry
            
            # If it is only partially contained within the superEntry AND
            # inclusion is &#39;lax&#39;, include it anyways
            elif mode == &#39;lax&#39; and (intervalStart &gt;= cropStart or
                                    intervalEnd &lt;= cropEnd):
                matchedEntry = entry
            
            # If not strict, include partial tiers on the edges
            # -- regardless, record how much information was lost
            #        - for strict=True, the total time of the cut interval
            #        - for strict=False, the portion of the interval that lies
            #            outside the new interval

            # The current interval stradles the end of the new interval
            elif intervalStart &gt;= cropStart and intervalEnd &gt; cropEnd:
                cutTEnd = intervalEnd - cropEnd
                lastIntervalKeptProportion = ((cropEnd - intervalStart) /
                                              (intervalEnd - intervalStart))

                if mode == &#34;truncated&#34;:
                    matchedEntry = (intervalStart, cropEnd, intervalLabel)
                    
                else:
                    cutTWithin += cropEnd - cropStart
            
            # The current interval stradles the start of the new interval
            elif intervalStart &lt; cropStart and intervalEnd &lt;= cropEnd:
                cutTStart = cropStart - intervalStart
                firstIntervalKeptProportion = ((intervalEnd - cropStart) /
                                               (intervalEnd - intervalStart))
                if mode == &#34;truncated&#34;:
                    matchedEntry = (cropStart, intervalEnd, intervalLabel)
                else:
                    cutTWithin += cropEnd - cropStart

            # The current interval contains the new interval completely
            elif intervalStart &lt;= cropStart and intervalEnd &gt;= cropEnd:

                if mode == &#34;lax&#34;:
                    matchedEntry = entry
                elif mode == &#34;truncated&#34;:
                    matchedEntry = (cropStart, cropEnd, intervalLabel)
                else:
                    cutTWithin += cropEnd - cropStart
                        
            if matchedEntry is not None:
                newEntryList.append(matchedEntry)

        if rebaseToZero is True:
            newEntryList = [(startT - cropStart, stopT - cropStart, label)
                            for startT, stopT, label in newEntryList]
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd

        # Create subtier
        croppedTier = IntervalTier(self.name, newEntryList, minT, maxT)
        
        # DEBUG info
#         debugInfo = (subTier, cutTStart, cutTWithin, cutTEnd,
#                      firstIntervalKeptProportion, lastIntervalKeptProportion)
    
        return croppedTier
    
    def difference(self, tier):
        &#39;&#39;&#39;
        Takes the set difference of this tier and the given one
        
        Any overlapping portions of entries with entries in this textgrid
        will be removed from the returned tier.
        &#39;&#39;&#39;
        retTier = self.new()
        
        for entry in tier.entryList:
            retTier = retTier.eraseRegion(entry[0],
                                          entry[1],
                                          collisionCode=&#39;truncate&#39;,
                                          doShrink=False)
        
        return retTier

    def editTimestamps(self, offset, allowOvershoot=False):
        &#39;&#39;&#39;
        Modifies all timestamps by a constant amount
        
        Can modify the interval start independent of the interval end
        
        If allowOvershoot is True, an interval can go beyond the bounds
        of the textgrid
        &#39;&#39;&#39;
        
        newEntryList = []
        for start, stop, label in self.entryList:
            
            newStart = offset + start
            newStop = offset + stop
            if allowOvershoot is not True:
                assert(newStart &gt;= self.minTimestamp)
                assert(newStop &lt;= self.maxTimestamp)
            
            if newStop &lt; 0:
                continue
            if newStart &lt; 0:
                newStart = 0
            
            if newStart &lt; 0:
                continue
            
            newEntryList.append((newStart, newStop, label))

        # Determine new min and max timestamps
        newMin = min([entry[0] for entry in newEntryList])
        newMax = max([entry[1] for entry in newEntryList])
        
        if newMin &gt; self.minTimestamp:
            newMin = self.minTimestamp
        
        if newMax &lt; self.maxTimestamp:
            newMax = self.maxTimestamp
        
        return IntervalTier(self.name, newEntryList, newMin, newMax)

    def eraseRegion(self, start, stop, collisionCode=None, doShrink=True):
        &#39;&#39;&#39;
        Makes a region in a tier blank (removes all contained entries)
        
        collisionCode: in the event that intervals exist in the insertion area,
                       one of three things may happen
        - &#39;truncate&#39; - partially contained entries will have the portion
                       removed that overlaps with the target entry
        - &#39;categorical&#39; - all entries that overlap, even partially, with the
                          target entry will be completely removed
        - None or any other value - AssertionError is thrown
        
        doShrink: if True, moves leftward by (/stop/ - /start/) amount,
                  each item that occurs after /stop/
        &#39;&#39;&#39;
        
        matchList = self.crop(start, stop, &#39;lax&#39;, False).entryList
        newTier = self.new()

        # if the collisionCode is not properly set it isn&#39;t clear what to do
        assert(collisionCode in [&#39;truncate&#39;, &#39;categorical&#39;])
        
        if len(matchList) == 0:
            pass
        else:
            # Remove all the matches from the entryList
            # Go in reverse order because we&#39;re destructively altering
            # the order of the list (messes up index order)
            for tmpEntry in matchList[::-1]:
                newTier.deleteEntry(tmpEntry)
            
            # If we&#39;re only truncating, reinsert entries on the left and
            # right edges
            if collisionCode == &#39;truncate&#39;:

                # Check left edge
                if matchList[0][0] &lt; start:
                    newEntry = (matchList[0][0], start, matchList[0][-1])
                    newTier.entryList.append(newEntry)
                    
                # Check right edge
                if matchList[-1][1] &gt; stop:
                    newEntry = (stop, matchList[-1][1], matchList[-1][-1])
                    newTier.entryList.append(newEntry)
        
        if doShrink is True:
            
            diff = stop - start
            newEntryList = []
            for entry in newTier.entryList:
                if entry[1] &lt;= start:
                    newEntryList.append(entry)
                elif entry[0] &gt;= stop:
                    newEntryList.append((entry[0] - diff,
                                         entry[1] - diff,
                                         entry[2]))
            
            # Special case: an interval that spanned the deleted
            # section
            for i in range(0, len(newEntryList) - 1):
                rightEdge = newEntryList[i][1] == start
                leftEdge = newEntryList[i + 1][0] == start
                sameLabel = (newEntryList[i][2] == newEntryList[i + 1][2])
                if rightEdge and leftEdge and sameLabel:
                    newEntry = (newEntryList[i][0],
                                newEntryList[i + 1][1],
                                newEntryList[i][2])
                
                    newEntryList.pop(i + 1)
                    newEntryList.pop(i)
                    newEntryList.insert(i, newEntry)
                    
                    # Only one interval can span the deleted section,
                    # so if we&#39;ve found it, move on
                    break
            
            newMax = newTier.maxTimestamp - diff
            newTier = newTier.new(entryList=newEntryList,
                                  maxTimestamp=newMax)
            
        return newTier
    
    def getValuesInIntervals(self, dataTupleList):
        &#39;&#39;&#39;
        Returns data from dataTupleList contained in labeled intervals
        
        dataTupleList should be of the form:
        [(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]
        &#39;&#39;&#39;
        
        returnList = []
        
        for interval in self.entryList:
            intervalDataList = utils.getValuesInInterval(dataTupleList,
                                                         interval[0],
                                                         interval[1])
            returnList.append((interval, intervalDataList))
        
        return returnList
            
    def getNonEntries(self):
        &#39;&#39;&#39;
        Returns the regions of the textgrid without labels
        
        This can include unlabeled segments and regions marked as silent.
        &#39;&#39;&#39;
        entryList = self.entryList
        invertedEntryList = [(entryList[i][1], entryList[i + 1][0], &#34;&#34;)
                             for i in range(len(entryList) - 1)]
        
        # Remove entries that have no duration (ie lie between two entries
        # that share a border)
        invertedEntryList = [entry for entry in invertedEntryList
                             if entry[0] &lt; entry[1]]
        
        if entryList[0][0] &gt; 0:
            invertedEntryList.insert(0, (0, entryList[0][0], &#34;&#34;))
        
        if entryList[-1][1] &lt; self.maxTimestamp:
            invertedEntryList.append((entryList[-1][1], self.maxTimestamp, &#34;&#34;))
        
        invertedEntryList = [entry if isinstance(entry, Interval)
                             else Interval(*entry)
                             for entry in invertedEntryList]
        
        return invertedEntryList
    
    def insertEntry(self, entry, warnFlag=True, collisionCode=None):
        &#39;&#39;&#39;
        inserts an interval into the tier
        
        collisionCode: in the event that intervals exist in the insertion area,
                        one of three things may happen
        - &#39;replace&#39; - existing items will be removed
        - &#39;merge&#39; - inserting item will be fused with existing items
        - None or any other value - TextgridCollisionException is thrown
        
        if warnFlag is True and collisionCode is not None,
        the user is notified of each collision
        &#39;&#39;&#39;
        startTime, endTime = entry[:2]
        
        matchList = self.crop(startTime, endTime, &#39;lax&#39;, False).entryList
        
        if len(matchList) == 0:
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;replace&#34;:
            for matchEntry in matchList:
                self.deleteEntry(matchEntry)
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;merge&#34;:
            for matchEntry in matchList:
                self.deleteEntry(matchEntry)
            matchList.append(entry)
            matchList.sort()  # By starting time
            
            newEntry = (min([entry[0] for entry in matchList]),
                        max([entry[1] for entry in matchList]),
                        &#34;-&#34;.join([entry[2] for entry in matchList]))
            self.entryList.append(Interval(*newEntry))
            
        else:
            raise TextgridCollisionException(self.name, entry, matchList)
            
        self.sort()
        
        if len(matchList) != 0 and warnFlag is True:
            fmtStr = &#34;Collision warning for %s with items %s of tier %s&#34;
            print((fmtStr % (str(entry), str(matchList), self.name)))
    
    def insertSpace(self, start, duration, collisionCode=None):
        &#39;&#39;&#39;
        Inserts a blank region into the tier
        
        collisionCode: in the event that an interval stradles the
                       starting point
        - &#39;stretch&#39; - stretches the interval by /duration/ amount
        - &#39;split&#39; - splits the interval into two--everything to the
                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds
        - &#39;no change&#39; - leaves the interval as is with no change
        - None or any other value - AssertionError is thrown
        &#39;&#39;&#39;

        # if the collisionCode is not properly set it isn&#39;t clear what to do
        assert(collisionCode in [&#39;stretch&#39;, &#39;split&#39;, &#39;no change&#39;])

        newEntryList = []
        for entry in self.entryList:
            # Entry exists before the insertion point
            if entry[1] &lt;= start:
                newEntryList.append(entry)
            # Entry exists after the insertion point
            elif entry[0] &gt;= start:
                newEntryList.append((entry[0] + duration,
                                     entry[1] + duration,
                                     entry[2]))
            # Entry straddles the insertion point
            elif entry[0] &lt;= start and entry[1] &gt; start:
                if collisionCode == &#39;stretch&#39;:
                    newEntryList.append((entry[0],
                                         entry[1] + duration,
                                         entry[2]))
                elif collisionCode == &#39;split&#39;:
                    # Left side of the split
                    newEntryList.append((entry[0],
                                         start,
                                         entry[2]))
                    # Right side of the split
                    newEntryList.append((start + duration,
                                         start + duration + (entry[1] - start),
                                         entry[2]))
                elif collisionCode == &#39;no change&#39;:
                    newEntryList.append(entry)
        
        newTier = self.new(entryList=newEntryList,
                           maxTimestamp=self.maxTimestamp + duration)
                    
        return newTier
       
    def intersection(self, tier):
        &#39;&#39;&#39;
        Takes the set intersection of this tier and the given one
        
        Only intervals that exist in both tiers will remain in the
        returned tier.  If intervals partially overlap, only the overlapping
        portion will be returned.
        &#39;&#39;&#39;
        retEntryList = []
        for start, stop, label in tier.entryList:
            subTier = self.crop(start, stop, &#34;truncated&#34;, False)
            
            # Combine the labels in the two tiers
            stub = &#34;%s-%%s&#34; % label
            subEntryList = [(subEntry[0], subEntry[1], stub % subEntry[2])
                            for subEntry in subTier.entryList]
            
            retEntryList.extend(subEntryList)
        
        newName = &#34;%s-%s&#34; % (self.name, tier.name)
        
        retTier = self.new(newName, retEntryList)
        
        return retTier

    def morph(self, targetTier, filterFunc=None):
        &#39;&#39;&#39;
        Morphs the duration of segments in this tier to those in another
        
        This preserves the labels and the duration of silence in
        this tier while changing the duration of labeled segments.
        &#39;&#39;&#39;
        cumulativeAdjustAmount = 0
        lastFromEnd = 0
        newEntryList = []
        allPoints = [self.entryList, targetTier.entryList]
        for fromEntry, targetEntry in utils.safeZip(allPoints, True):
            
            fromStart, fromEnd, fromLabel = fromEntry
            targetStart, targetEnd = targetEntry[:2]
            
            # fromStart - lastFromEnd -&gt; was this interval and the
            # last one adjacent?
            toStart = (fromStart - lastFromEnd) + cumulativeAdjustAmount

            currAdjustAmount = (fromEnd - fromStart)
            if filterFunc is None or filterFunc(fromLabel):
                currAdjustAmount = (targetEnd - targetStart)
            
            toEnd = cumulativeAdjustAmount = toStart + currAdjustAmount
            newEntryList.append((toStart, toEnd, fromLabel))
            
            lastFromEnd = fromEnd
            
        newMin = self.minTimestamp
        cumulativeDifference = (newEntryList[-1][1] - self.entryList[-1][1])
        newMax = self.maxTimestamp + cumulativeDifference
            
        return IntervalTier(self.name, newEntryList, newMin, newMax)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="praatio.tgio.TextgridTier" href="#praatio.tgio.TextgridTier">TextgridTier</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="praatio.tgio.IntervalTier.tierType"><code class="name">var <span class="ident">tierType</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="praatio.tgio.IntervalTier.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, cropStart, cropEnd, mode, rebaseToZero)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new tier with all entries that fit inside the new interval</p>
<p>mode = {'strict', 'lax', 'truncated'}
If 'strict', only intervals wholly contained by the crop
interval will be kept
If 'lax', partially contained intervals will be kept
If 'truncated', partially contained intervals will be
truncated to fit within the crop region.</p>
<p>If rebaseToZero is True, the cropped textgrid values will be
subtracted by the cropStart</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def crop(self, cropStart, cropEnd, mode, rebaseToZero):
        &#39;&#39;&#39;
        Creates a new tier with all entries that fit inside the new interval
        
        mode = {&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;}
            If &#39;strict&#39;, only intervals wholly contained by the crop
                interval will be kept
            If &#39;lax&#39;, partially contained intervals will be kept
            If &#39;truncated&#39;, partially contained intervals will be
                truncated to fit within the crop region.
        
        If rebaseToZero is True, the cropped textgrid values will be
            subtracted by the cropStart
        &#39;&#39;&#39;
        
        assert(mode in [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;])
        
        # Debugging variables
        cutTStart = 0
        cutTWithin = 0
        cutTEnd = 0
        firstIntervalKeptProportion = 0
        lastIntervalKeptProportion = 0
        
        newEntryList = []
        for entry in self.entryList:
            matchedEntry = None
            
            intervalStart = entry[0]
            intervalEnd = entry[1]
            intervalLabel = entry[2]
            
            # Don&#39;t need to investigate if the interval is before or after
            # the crop region
            if intervalEnd &lt;= cropStart or intervalStart &gt;= cropEnd:
                continue
            
            # Determine if the current subEntry is wholly contained
            # within the superEntry
            if intervalStart &gt;= cropStart and intervalEnd &lt;= cropEnd:
                matchedEntry = entry
            
            # If it is only partially contained within the superEntry AND
            # inclusion is &#39;lax&#39;, include it anyways
            elif mode == &#39;lax&#39; and (intervalStart &gt;= cropStart or
                                    intervalEnd &lt;= cropEnd):
                matchedEntry = entry
            
            # If not strict, include partial tiers on the edges
            # -- regardless, record how much information was lost
            #        - for strict=True, the total time of the cut interval
            #        - for strict=False, the portion of the interval that lies
            #            outside the new interval

            # The current interval stradles the end of the new interval
            elif intervalStart &gt;= cropStart and intervalEnd &gt; cropEnd:
                cutTEnd = intervalEnd - cropEnd
                lastIntervalKeptProportion = ((cropEnd - intervalStart) /
                                              (intervalEnd - intervalStart))

                if mode == &#34;truncated&#34;:
                    matchedEntry = (intervalStart, cropEnd, intervalLabel)
                    
                else:
                    cutTWithin += cropEnd - cropStart
            
            # The current interval stradles the start of the new interval
            elif intervalStart &lt; cropStart and intervalEnd &lt;= cropEnd:
                cutTStart = cropStart - intervalStart
                firstIntervalKeptProportion = ((intervalEnd - cropStart) /
                                               (intervalEnd - intervalStart))
                if mode == &#34;truncated&#34;:
                    matchedEntry = (cropStart, intervalEnd, intervalLabel)
                else:
                    cutTWithin += cropEnd - cropStart

            # The current interval contains the new interval completely
            elif intervalStart &lt;= cropStart and intervalEnd &gt;= cropEnd:

                if mode == &#34;lax&#34;:
                    matchedEntry = entry
                elif mode == &#34;truncated&#34;:
                    matchedEntry = (cropStart, cropEnd, intervalLabel)
                else:
                    cutTWithin += cropEnd - cropStart
                        
            if matchedEntry is not None:
                newEntryList.append(matchedEntry)

        if rebaseToZero is True:
            newEntryList = [(startT - cropStart, stopT - cropStart, label)
                            for startT, stopT, label in newEntryList]
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd

        # Create subtier
        croppedTier = IntervalTier(self.name, newEntryList, minT, maxT)
        
        # DEBUG info
#         debugInfo = (subTier, cutTStart, cutTWithin, cutTEnd,
#                      firstIntervalKeptProportion, lastIntervalKeptProportion)
    
        return croppedTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.difference"><code class="name flex">
<span>def <span class="ident">difference</span></span>(<span>self, tier)</span>
</code></dt>
<dd>
<section class="desc"><p>Takes the set difference of this tier and the given one</p>
<p>Any overlapping portions of entries with entries in this textgrid
will be removed from the returned tier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def difference(self, tier):
    &#39;&#39;&#39;
    Takes the set difference of this tier and the given one
    
    Any overlapping portions of entries with entries in this textgrid
    will be removed from the returned tier.
    &#39;&#39;&#39;
    retTier = self.new()
    
    for entry in tier.entryList:
        retTier = retTier.eraseRegion(entry[0],
                                      entry[1],
                                      collisionCode=&#39;truncate&#39;,
                                      doShrink=False)
    
    return retTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.editTimestamps"><code class="name flex">
<span>def <span class="ident">editTimestamps</span></span>(<span>self, offset, allowOvershoot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Modifies all timestamps by a constant amount</p>
<p>Can modify the interval start independent of the interval end</p>
<p>If allowOvershoot is True, an interval can go beyond the bounds
of the textgrid</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editTimestamps(self, offset, allowOvershoot=False):
    &#39;&#39;&#39;
    Modifies all timestamps by a constant amount
    
    Can modify the interval start independent of the interval end
    
    If allowOvershoot is True, an interval can go beyond the bounds
    of the textgrid
    &#39;&#39;&#39;
    
    newEntryList = []
    for start, stop, label in self.entryList:
        
        newStart = offset + start
        newStop = offset + stop
        if allowOvershoot is not True:
            assert(newStart &gt;= self.minTimestamp)
            assert(newStop &lt;= self.maxTimestamp)
        
        if newStop &lt; 0:
            continue
        if newStart &lt; 0:
            newStart = 0
        
        if newStart &lt; 0:
            continue
        
        newEntryList.append((newStart, newStop, label))

    # Determine new min and max timestamps
    newMin = min([entry[0] for entry in newEntryList])
    newMax = max([entry[1] for entry in newEntryList])
    
    if newMin &gt; self.minTimestamp:
        newMin = self.minTimestamp
    
    if newMax &lt; self.maxTimestamp:
        newMax = self.maxTimestamp
    
    return IntervalTier(self.name, newEntryList, newMin, newMax)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.eraseRegion"><code class="name flex">
<span>def <span class="ident">eraseRegion</span></span>(<span>self, start, stop, collisionCode=None, doShrink=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes a region in a tier blank (removes all contained entries)</p>
<p>collisionCode: in the event that intervals exist in the insertion area,
one of three things may happen
- 'truncate' - partially contained entries will have the portion
removed that overlaps with the target entry
- 'categorical' - all entries that overlap, even partially, with the
target entry will be completely removed
- None or any other value - AssertionError is thrown</p>
<p>doShrink: if True, moves leftward by (/stop/ - /start/) amount,
each item that occurs after /stop/</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eraseRegion(self, start, stop, collisionCode=None, doShrink=True):
    &#39;&#39;&#39;
    Makes a region in a tier blank (removes all contained entries)
    
    collisionCode: in the event that intervals exist in the insertion area,
                   one of three things may happen
    - &#39;truncate&#39; - partially contained entries will have the portion
                   removed that overlaps with the target entry
    - &#39;categorical&#39; - all entries that overlap, even partially, with the
                      target entry will be completely removed
    - None or any other value - AssertionError is thrown
    
    doShrink: if True, moves leftward by (/stop/ - /start/) amount,
              each item that occurs after /stop/
    &#39;&#39;&#39;
    
    matchList = self.crop(start, stop, &#39;lax&#39;, False).entryList
    newTier = self.new()

    # if the collisionCode is not properly set it isn&#39;t clear what to do
    assert(collisionCode in [&#39;truncate&#39;, &#39;categorical&#39;])
    
    if len(matchList) == 0:
        pass
    else:
        # Remove all the matches from the entryList
        # Go in reverse order because we&#39;re destructively altering
        # the order of the list (messes up index order)
        for tmpEntry in matchList[::-1]:
            newTier.deleteEntry(tmpEntry)
        
        # If we&#39;re only truncating, reinsert entries on the left and
        # right edges
        if collisionCode == &#39;truncate&#39;:

            # Check left edge
            if matchList[0][0] &lt; start:
                newEntry = (matchList[0][0], start, matchList[0][-1])
                newTier.entryList.append(newEntry)
                
            # Check right edge
            if matchList[-1][1] &gt; stop:
                newEntry = (stop, matchList[-1][1], matchList[-1][-1])
                newTier.entryList.append(newEntry)
    
    if doShrink is True:
        
        diff = stop - start
        newEntryList = []
        for entry in newTier.entryList:
            if entry[1] &lt;= start:
                newEntryList.append(entry)
            elif entry[0] &gt;= stop:
                newEntryList.append((entry[0] - diff,
                                     entry[1] - diff,
                                     entry[2]))
        
        # Special case: an interval that spanned the deleted
        # section
        for i in range(0, len(newEntryList) - 1):
            rightEdge = newEntryList[i][1] == start
            leftEdge = newEntryList[i + 1][0] == start
            sameLabel = (newEntryList[i][2] == newEntryList[i + 1][2])
            if rightEdge and leftEdge and sameLabel:
                newEntry = (newEntryList[i][0],
                            newEntryList[i + 1][1],
                            newEntryList[i][2])
            
                newEntryList.pop(i + 1)
                newEntryList.pop(i)
                newEntryList.insert(i, newEntry)
                
                # Only one interval can span the deleted section,
                # so if we&#39;ve found it, move on
                break
        
        newMax = newTier.maxTimestamp - diff
        newTier = newTier.new(entryList=newEntryList,
                              maxTimestamp=newMax)
        
    return newTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.getNonEntries"><code class="name flex">
<span>def <span class="ident">getNonEntries</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the regions of the textgrid without labels</p>
<p>This can include unlabeled segments and regions marked as silent.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNonEntries(self):
    &#39;&#39;&#39;
    Returns the regions of the textgrid without labels
    
    This can include unlabeled segments and regions marked as silent.
    &#39;&#39;&#39;
    entryList = self.entryList
    invertedEntryList = [(entryList[i][1], entryList[i + 1][0], &#34;&#34;)
                         for i in range(len(entryList) - 1)]
    
    # Remove entries that have no duration (ie lie between two entries
    # that share a border)
    invertedEntryList = [entry for entry in invertedEntryList
                         if entry[0] &lt; entry[1]]
    
    if entryList[0][0] &gt; 0:
        invertedEntryList.insert(0, (0, entryList[0][0], &#34;&#34;))
    
    if entryList[-1][1] &lt; self.maxTimestamp:
        invertedEntryList.append((entryList[-1][1], self.maxTimestamp, &#34;&#34;))
    
    invertedEntryList = [entry if isinstance(entry, Interval)
                         else Interval(*entry)
                         for entry in invertedEntryList]
    
    return invertedEntryList</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.getValuesInIntervals"><code class="name flex">
<span>def <span class="ident">getValuesInIntervals</span></span>(<span>self, dataTupleList)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns data from dataTupleList contained in labeled intervals</p>
<p>dataTupleList should be of the form:
[(time1, value1a, value1b,&hellip;), (time2, value2a, value2b&hellip;), &hellip;]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValuesInIntervals(self, dataTupleList):
    &#39;&#39;&#39;
    Returns data from dataTupleList contained in labeled intervals
    
    dataTupleList should be of the form:
    [(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]
    &#39;&#39;&#39;
    
    returnList = []
    
    for interval in self.entryList:
        intervalDataList = utils.getValuesInInterval(dataTupleList,
                                                     interval[0],
                                                     interval[1])
        returnList.append((interval, intervalDataList))
    
    return returnList</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.insertEntry"><code class="name flex">
<span>def <span class="ident">insertEntry</span></span>(<span>self, entry, warnFlag=True, collisionCode=None)</span>
</code></dt>
<dd>
<section class="desc"><p>inserts an interval into the tier</p>
<p>collisionCode: in the event that intervals exist in the insertion area,
one of three things may happen
- 'replace' - existing items will be removed
- 'merge' - inserting item will be fused with existing items
- None or any other value - TextgridCollisionException is thrown</p>
<p>if warnFlag is True and collisionCode is not None,
the user is notified of each collision</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertEntry(self, entry, warnFlag=True, collisionCode=None):
    &#39;&#39;&#39;
    inserts an interval into the tier
    
    collisionCode: in the event that intervals exist in the insertion area,
                    one of three things may happen
    - &#39;replace&#39; - existing items will be removed
    - &#39;merge&#39; - inserting item will be fused with existing items
    - None or any other value - TextgridCollisionException is thrown
    
    if warnFlag is True and collisionCode is not None,
    the user is notified of each collision
    &#39;&#39;&#39;
    startTime, endTime = entry[:2]
    
    matchList = self.crop(startTime, endTime, &#39;lax&#39;, False).entryList
    
    if len(matchList) == 0:
        self.entryList.append(entry)
        
    elif collisionCode.lower() == &#34;replace&#34;:
        for matchEntry in matchList:
            self.deleteEntry(matchEntry)
        self.entryList.append(entry)
        
    elif collisionCode.lower() == &#34;merge&#34;:
        for matchEntry in matchList:
            self.deleteEntry(matchEntry)
        matchList.append(entry)
        matchList.sort()  # By starting time
        
        newEntry = (min([entry[0] for entry in matchList]),
                    max([entry[1] for entry in matchList]),
                    &#34;-&#34;.join([entry[2] for entry in matchList]))
        self.entryList.append(Interval(*newEntry))
        
    else:
        raise TextgridCollisionException(self.name, entry, matchList)
        
    self.sort()
    
    if len(matchList) != 0 and warnFlag is True:
        fmtStr = &#34;Collision warning for %s with items %s of tier %s&#34;
        print((fmtStr % (str(entry), str(matchList), self.name)))</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.insertSpace"><code class="name flex">
<span>def <span class="ident">insertSpace</span></span>(<span>self, start, duration, collisionCode=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Inserts a blank region into the tier</p>
<p>collisionCode: in the event that an interval stradles the
starting point
- 'stretch' - stretches the interval by /duration/ amount
- 'split' - splits the interval into two&ndash;everything to the
right of 'start' will be advanced by 'duration' seconds
- 'no change' - leaves the interval as is with no change
- None or any other value - AssertionError is thrown</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertSpace(self, start, duration, collisionCode=None):
    &#39;&#39;&#39;
    Inserts a blank region into the tier
    
    collisionCode: in the event that an interval stradles the
                   starting point
    - &#39;stretch&#39; - stretches the interval by /duration/ amount
    - &#39;split&#39; - splits the interval into two--everything to the
                right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds
    - &#39;no change&#39; - leaves the interval as is with no change
    - None or any other value - AssertionError is thrown
    &#39;&#39;&#39;

    # if the collisionCode is not properly set it isn&#39;t clear what to do
    assert(collisionCode in [&#39;stretch&#39;, &#39;split&#39;, &#39;no change&#39;])

    newEntryList = []
    for entry in self.entryList:
        # Entry exists before the insertion point
        if entry[1] &lt;= start:
            newEntryList.append(entry)
        # Entry exists after the insertion point
        elif entry[0] &gt;= start:
            newEntryList.append((entry[0] + duration,
                                 entry[1] + duration,
                                 entry[2]))
        # Entry straddles the insertion point
        elif entry[0] &lt;= start and entry[1] &gt; start:
            if collisionCode == &#39;stretch&#39;:
                newEntryList.append((entry[0],
                                     entry[1] + duration,
                                     entry[2]))
            elif collisionCode == &#39;split&#39;:
                # Left side of the split
                newEntryList.append((entry[0],
                                     start,
                                     entry[2]))
                # Right side of the split
                newEntryList.append((start + duration,
                                     start + duration + (entry[1] - start),
                                     entry[2]))
            elif collisionCode == &#39;no change&#39;:
                newEntryList.append(entry)
    
    newTier = self.new(entryList=newEntryList,
                       maxTimestamp=self.maxTimestamp + duration)
                
    return newTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, tier)</span>
</code></dt>
<dd>
<section class="desc"><p>Takes the set intersection of this tier and the given one</p>
<p>Only intervals that exist in both tiers will remain in the
returned tier.
If intervals partially overlap, only the overlapping
portion will be returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, tier):
    &#39;&#39;&#39;
    Takes the set intersection of this tier and the given one
    
    Only intervals that exist in both tiers will remain in the
    returned tier.  If intervals partially overlap, only the overlapping
    portion will be returned.
    &#39;&#39;&#39;
    retEntryList = []
    for start, stop, label in tier.entryList:
        subTier = self.crop(start, stop, &#34;truncated&#34;, False)
        
        # Combine the labels in the two tiers
        stub = &#34;%s-%%s&#34; % label
        subEntryList = [(subEntry[0], subEntry[1], stub % subEntry[2])
                        for subEntry in subTier.entryList]
        
        retEntryList.extend(subEntryList)
    
    newName = &#34;%s-%s&#34; % (self.name, tier.name)
    
    retTier = self.new(newName, retEntryList)
    
    return retTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.IntervalTier.morph"><code class="name flex">
<span>def <span class="ident">morph</span></span>(<span>self, targetTier, filterFunc=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Morphs the duration of segments in this tier to those in another</p>
<p>This preserves the labels and the duration of silence in
this tier while changing the duration of labeled segments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def morph(self, targetTier, filterFunc=None):
    &#39;&#39;&#39;
    Morphs the duration of segments in this tier to those in another
    
    This preserves the labels and the duration of silence in
    this tier while changing the duration of labeled segments.
    &#39;&#39;&#39;
    cumulativeAdjustAmount = 0
    lastFromEnd = 0
    newEntryList = []
    allPoints = [self.entryList, targetTier.entryList]
    for fromEntry, targetEntry in utils.safeZip(allPoints, True):
        
        fromStart, fromEnd, fromLabel = fromEntry
        targetStart, targetEnd = targetEntry[:2]
        
        # fromStart - lastFromEnd -&gt; was this interval and the
        # last one adjacent?
        toStart = (fromStart - lastFromEnd) + cumulativeAdjustAmount

        currAdjustAmount = (fromEnd - fromStart)
        if filterFunc is None or filterFunc(fromLabel):
            currAdjustAmount = (targetEnd - targetStart)
        
        toEnd = cumulativeAdjustAmount = toStart + currAdjustAmount
        newEntryList.append((toStart, toEnd, fromLabel))
        
        lastFromEnd = fromEnd
        
    newMin = self.minTimestamp
    cumulativeDifference = (newEntryList[-1][1] - self.entryList[-1][1])
    newMax = self.maxTimestamp + cumulativeDifference
        
    return IntervalTier(self.name, newEntryList, newMin, newMax)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="praatio.tgio.TextgridTier" href="#praatio.tgio.TextgridTier">TextgridTier</a></b></code>:
<ul class="hlist">
<li><code><a title="praatio.tgio.TextgridTier.appendTier" href="#praatio.tgio.TextgridTier.appendTier">appendTier</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.deleteEntry" href="#praatio.tgio.TextgridTier.deleteEntry">deleteEntry</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.entryType" href="#praatio.tgio.TextgridTier.entryType">entryType</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.find" href="#praatio.tgio.TextgridTier.find">find</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.getAsText" href="#praatio.tgio.TextgridTier.getAsText">getAsText</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.new" href="#praatio.tgio.TextgridTier.new">new</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.sort" href="#praatio.tgio.TextgridTier.sort">sort</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.union" href="#praatio.tgio.TextgridTier.union">union</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="praatio.tgio.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>time, label)</span>
</code></dt>
<dd>
<section class="desc"><p>Point(time, label)</p></section>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="praatio.tgio.Point.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="praatio.tgio.Point.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
</dl>
</dd>
<dt id="praatio.tgio.PointTier"><code class="flex name class">
<span>class <span class="ident">PointTier</span></span>
<span>(</span><span>name, entryList, minT=None, maxT=None, pairedWav=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A point tier is for annotating instaneous events</p>
<p>The entryList is of the form:
[(timeVal1, label1), (timeVal2, label2), ]</p>
<p>The data stored in the labels can be anything but will
be interpreted as text by praatio (the label could be descriptive
text e.g. ('peak point here') or numerical data e.g. (pitch values
like '132'))</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointTier(TextgridTier):
    
    tierType = POINT_TIER
    entryType = Point
    
    def __init__(self, name, entryList, minT=None, maxT=None,
                 pairedWav=None):
        &#39;&#39;&#39;
        A point tier is for annotating instaneous events
        
        The entryList is of the form:
        [(timeVal1, label1), (timeVal2, label2), ]
        
        The data stored in the labels can be anything but will
        be interpreted as text by praatio (the label could be descriptive
        text e.g. (&#39;peak point here&#39;) or numerical data e.g. (pitch values
        like &#39;132&#39;))
        &#39;&#39;&#39;
        
        entryList = [Point(float(time), label) for time, label in entryList]
        
        # Determine the min and max timestamps
        timeList = [time for time, label in entryList]
        if minT is not None:
            timeList.append(float(minT))
        if maxT is not None:
            timeList.append(float(maxT))
            
        if maxT is None and pairedWav is not None:
            maxT = _getWavDuration(pairedWav)
        
        try:
            minT = min(timeList)
            maxT = max(timeList)
        except ValueError:
            raise TimelessTextgridTierException()

        super(PointTier, self).__init__(name, entryList, minT, maxT)

    def crop(self, cropStart, cropEnd, mode=None,
             rebaseToZero=True):
        &#39;&#39;&#39;
        Creates a new tier containing all entries inside the new interval
        
        mode is ignored.  This parameter is kept for compatibility with
        IntervalTier.crop()
        &#39;&#39;&#39;
        newEntryList = []
        
        for entry in self.entryList:
            timestamp = entry[0]
            
            if timestamp &gt;= cropStart and timestamp &lt;= cropEnd:
                newEntryList.append(entry)

        if rebaseToZero is True:
            newEntryList = [(timeV - cropStart, label)
                            for timeV, label in newEntryList]
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd

        # Create subtier
        subTier = PointTier(self.name, newEntryList, minT, maxT)
        return subTier

    def editTimestamps(self, offset, allowOvershoot=False):
        &#39;&#39;&#39;
        Modifies all timestamps by a constant amount
        
        If allowOvershoot is True, an interval can go beyond the bounds
        of the textgrid
        &#39;&#39;&#39;
        
        newEntryList = []
        for timestamp, label in self.entryList:
            
            newTimestamp = timestamp + offset
            if not allowOvershoot:
                assert(newTimestamp &gt; self.minTimestamp)
                assert(newTimestamp &lt;= self.maxTimestamp)
            
            if newTimestamp &lt; 0:
                continue
            
            newEntryList.append((newTimestamp, label))
        
        # Determine new min and max timestamps
        timeList = [float(subList[0]) for subList in newEntryList]
        newMin = min(timeList)
        newMax = max(timeList)
        
        if newMin &gt; self.minTimestamp:
            newMin = self.minTimestamp
        
        if newMax &lt; self.maxTimestamp:
            newMax = self.maxTimestamp
        
        return PointTier(self.name, newEntryList, newMin, newMax)
    
    def getValuesAtPoints(self, dataTupleList, fuzzyMatching=False):
        &#39;&#39;&#39;
        Get the values that occur at points in the point tier
        
        If fuzzyMatching is True, if there is not a feature value
        at a point, the nearest feature value will be taken.
        
        The procedure assumes that all data is ordered in time.
        dataTupleList should be in the form
        [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]
        
        The procedure makes one pass through dataTupleList and one
        pass through self.entryList.  If the data is not sequentially
        ordered, the incorrect response will be returned.
        &#39;&#39;&#39;
        
        i = 0
        retList = []
        
        sortedDataTupleList = dataTupleList.sorted()
        for timestamp, label in self.entryList:
            retTuple = utils.getValueAtTime(timestamp,
                                            sortedDataTupleList,
                                            fuzzyMatching=fuzzyMatching,
                                            startI=i)
            retTime, retVal, i = retTuple
            retList.append((retTime, label, retVal))
    
        return retList
        
    def eraseRegion(self, start, stop, collisionCode=None, doShrink=True):
        &#39;&#39;&#39;
        Makes a region in a tier blank (removes all contained entries)
        
        collisionCode: Ignored for the moment (added for compatibility
                       with eraseRegion() for Interval Tiers)
        doShrink: if True, moves leftward by (/stop/ - /start/)
                  all points to the right of /stop/
        &#39;&#39;&#39;

        newTier = self.new()
        croppedTier = newTier.crop(start, stop, &#34;truncated&#34;, False)
        matchList = croppedTier.entryList
        
        if len(matchList) == 0:
            pass
        else:
            
            # Remove all the matches from the entryList
            # Go in reverse order because we&#39;re destructively altering
            # the order of the list (messes up index order)
            for tmpEntry in matchList[::-1]:
                newTier.deleteEntry(tmpEntry)
                
        if doShrink is True:
            newEntryList = []
            diff = stop - start
            for timestamp, label in newTier.entryList:
                if timestamp &lt; start:
                    newEntryList.append((timestamp, label))
                elif timestamp &gt; stop:
                    newEntryList.append((timestamp - diff, label))
            
            newMax = newTier.maxTimestamp - diff
            newTier = newTier.new(entryList=newEntryList,
                                  maxTimestamp=newMax)
                    
        return newTier
                
    def insertEntry(self, entry, warnFlag=True, collisionCode=None):
        &#39;&#39;&#39;
        inserts an interval into the tier
        
        collisionCode: in the event that intervals exist in the insertion area,
                        one of three things may happen
        - &#39;replace&#39; - existing items will be removed
        - &#39;merge&#39; - inserting item will be fused with existing items
        - None or any other value - TextgridCollisionException is thrown
        
        if warnFlag is True and collisionCode is not None,
        the user is notified of each collision
        &#39;&#39;&#39;
        timestamp, label = entry
        
        if not isinstance(entry, Point):
            entry = Point(timestamp, label)
        
        matchList = []
        i = None
        for i, searchEntry in self.entryList:
            if searchEntry[0] == entry[0]:
                matchList.append(searchEntry)
                break
        
        if len(matchList) == 0:
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;replace&#34;:
            self.deleteEntry(self.entryList[i])
            self.entryList.append(entry)
            
        elif collisionCode.lower() == &#34;merge&#34;:
            oldEntry = self.entryList[i]
            newEntry = Point(timestamp, &#34;-&#34;.join([oldEntry[-1], label]))
            self.deleteEntry(self.entryList[i])
            self.entryList.append(newEntry)
            
        else:
            raise TextgridCollisionException(self.name, entry, matchList)
            
        self.sort()
        
        if len(matchList) != 0 and warnFlag is True:
            fmtStr = &#34;Collision warning for %s with items %s of tier %s&#34;
            print((fmtStr % (str(entry), str(matchList), self.name)))
    
    def insertSpace(self, start, duration, collisionCode=None):
        &#39;&#39;&#39;
        Inserts a region into the tier
        
        collisionCode: Ignored for the moment (added for compatibility
                       with insertSpace() for Interval Tiers)
        &#39;&#39;&#39;
        
        newEntryList = []
        for entry in self.entryList:
            if entry[0] &lt;= start:
                newEntryList.append(entry)
            elif entry[0] &gt; start:
                newEntryList.append((entry[0] + duration, entry[1]))
                
        newTier = self.new(entryList=newEntryList,
                           maxTimestamp=self.maxTimestamp + duration)
        
        return newTier</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="praatio.tgio.TextgridTier" href="#praatio.tgio.TextgridTier">TextgridTier</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="praatio.tgio.PointTier.entryType"><code class="name">var <span class="ident">entryType</span></code></dt>
<dd>
<section class="desc"><p>Point(time, label)</p></section>
</dd>
<dt id="praatio.tgio.PointTier.tierType"><code class="name">var <span class="ident">tierType</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="praatio.tgio.PointTier.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, cropStart, cropEnd, mode=None, rebaseToZero=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new tier containing all entries inside the new interval</p>
<p>mode is ignored.
This parameter is kept for compatibility with
IntervalTier.crop()</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop(self, cropStart, cropEnd, mode=None,
         rebaseToZero=True):
    &#39;&#39;&#39;
    Creates a new tier containing all entries inside the new interval
    
    mode is ignored.  This parameter is kept for compatibility with
    IntervalTier.crop()
    &#39;&#39;&#39;
    newEntryList = []
    
    for entry in self.entryList:
        timestamp = entry[0]
        
        if timestamp &gt;= cropStart and timestamp &lt;= cropEnd:
            newEntryList.append(entry)

    if rebaseToZero is True:
        newEntryList = [(timeV - cropStart, label)
                        for timeV, label in newEntryList]
        minT = 0
        maxT = cropEnd - cropStart
    else:
        minT = cropStart
        maxT = cropEnd

    # Create subtier
    subTier = PointTier(self.name, newEntryList, minT, maxT)
    return subTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.PointTier.editTimestamps"><code class="name flex">
<span>def <span class="ident">editTimestamps</span></span>(<span>self, offset, allowOvershoot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Modifies all timestamps by a constant amount</p>
<p>If allowOvershoot is True, an interval can go beyond the bounds
of the textgrid</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editTimestamps(self, offset, allowOvershoot=False):
    &#39;&#39;&#39;
    Modifies all timestamps by a constant amount
    
    If allowOvershoot is True, an interval can go beyond the bounds
    of the textgrid
    &#39;&#39;&#39;
    
    newEntryList = []
    for timestamp, label in self.entryList:
        
        newTimestamp = timestamp + offset
        if not allowOvershoot:
            assert(newTimestamp &gt; self.minTimestamp)
            assert(newTimestamp &lt;= self.maxTimestamp)
        
        if newTimestamp &lt; 0:
            continue
        
        newEntryList.append((newTimestamp, label))
    
    # Determine new min and max timestamps
    timeList = [float(subList[0]) for subList in newEntryList]
    newMin = min(timeList)
    newMax = max(timeList)
    
    if newMin &gt; self.minTimestamp:
        newMin = self.minTimestamp
    
    if newMax &lt; self.maxTimestamp:
        newMax = self.maxTimestamp
    
    return PointTier(self.name, newEntryList, newMin, newMax)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.PointTier.eraseRegion"><code class="name flex">
<span>def <span class="ident">eraseRegion</span></span>(<span>self, start, stop, collisionCode=None, doShrink=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes a region in a tier blank (removes all contained entries)</p>
<p>collisionCode: Ignored for the moment (added for compatibility
with eraseRegion() for Interval Tiers)
doShrink: if True, moves leftward by (/stop/ - /start/)
all points to the right of /stop/</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eraseRegion(self, start, stop, collisionCode=None, doShrink=True):
    &#39;&#39;&#39;
    Makes a region in a tier blank (removes all contained entries)
    
    collisionCode: Ignored for the moment (added for compatibility
                   with eraseRegion() for Interval Tiers)
    doShrink: if True, moves leftward by (/stop/ - /start/)
              all points to the right of /stop/
    &#39;&#39;&#39;

    newTier = self.new()
    croppedTier = newTier.crop(start, stop, &#34;truncated&#34;, False)
    matchList = croppedTier.entryList
    
    if len(matchList) == 0:
        pass
    else:
        
        # Remove all the matches from the entryList
        # Go in reverse order because we&#39;re destructively altering
        # the order of the list (messes up index order)
        for tmpEntry in matchList[::-1]:
            newTier.deleteEntry(tmpEntry)
            
    if doShrink is True:
        newEntryList = []
        diff = stop - start
        for timestamp, label in newTier.entryList:
            if timestamp &lt; start:
                newEntryList.append((timestamp, label))
            elif timestamp &gt; stop:
                newEntryList.append((timestamp - diff, label))
        
        newMax = newTier.maxTimestamp - diff
        newTier = newTier.new(entryList=newEntryList,
                              maxTimestamp=newMax)
                
    return newTier</code></pre>
</details>
</dd>
<dt id="praatio.tgio.PointTier.getValuesAtPoints"><code class="name flex">
<span>def <span class="ident">getValuesAtPoints</span></span>(<span>self, dataTupleList, fuzzyMatching=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the values that occur at points in the point tier</p>
<p>If fuzzyMatching is True, if there is not a feature value
at a point, the nearest feature value will be taken.</p>
<p>The procedure assumes that all data is ordered in time.
dataTupleList should be in the form
[(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]</p>
<p>The procedure makes one pass through dataTupleList and one
pass through self.entryList.
If the data is not sequentially
ordered, the incorrect response will be returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValuesAtPoints(self, dataTupleList, fuzzyMatching=False):
    &#39;&#39;&#39;
    Get the values that occur at points in the point tier
    
    If fuzzyMatching is True, if there is not a feature value
    at a point, the nearest feature value will be taken.
    
    The procedure assumes that all data is ordered in time.
    dataTupleList should be in the form
    [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]
    
    The procedure makes one pass through dataTupleList and one
    pass through self.entryList.  If the data is not sequentially
    ordered, the incorrect response will be returned.
    &#39;&#39;&#39;
    
    i = 0
    retList = []
    
    sortedDataTupleList = dataTupleList.sorted()
    for timestamp, label in self.entryList:
        retTuple = utils.getValueAtTime(timestamp,
                                        sortedDataTupleList,
                                        fuzzyMatching=fuzzyMatching,
                                        startI=i)
        retTime, retVal, i = retTuple
        retList.append((retTime, label, retVal))

    return retList</code></pre>
</details>
</dd>
<dt id="praatio.tgio.PointTier.insertEntry"><code class="name flex">
<span>def <span class="ident">insertEntry</span></span>(<span>self, entry, warnFlag=True, collisionCode=None)</span>
</code></dt>
<dd>
<section class="desc"><p>inserts an interval into the tier</p>
<p>collisionCode: in the event that intervals exist in the insertion area,
one of three things may happen
- 'replace' - existing items will be removed
- 'merge' - inserting item will be fused with existing items
- None or any other value - TextgridCollisionException is thrown</p>
<p>if warnFlag is True and collisionCode is not None,
the user is notified of each collision</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertEntry(self, entry, warnFlag=True, collisionCode=None):
    &#39;&#39;&#39;
    inserts an interval into the tier
    
    collisionCode: in the event that intervals exist in the insertion area,
                    one of three things may happen
    - &#39;replace&#39; - existing items will be removed
    - &#39;merge&#39; - inserting item will be fused with existing items
    - None or any other value - TextgridCollisionException is thrown
    
    if warnFlag is True and collisionCode is not None,
    the user is notified of each collision
    &#39;&#39;&#39;
    timestamp, label = entry
    
    if not isinstance(entry, Point):
        entry = Point(timestamp, label)
    
    matchList = []
    i = None
    for i, searchEntry in self.entryList:
        if searchEntry[0] == entry[0]:
            matchList.append(searchEntry)
            break
    
    if len(matchList) == 0:
        self.entryList.append(entry)
        
    elif collisionCode.lower() == &#34;replace&#34;:
        self.deleteEntry(self.entryList[i])
        self.entryList.append(entry)
        
    elif collisionCode.lower() == &#34;merge&#34;:
        oldEntry = self.entryList[i]
        newEntry = Point(timestamp, &#34;-&#34;.join([oldEntry[-1], label]))
        self.deleteEntry(self.entryList[i])
        self.entryList.append(newEntry)
        
    else:
        raise TextgridCollisionException(self.name, entry, matchList)
        
    self.sort()
    
    if len(matchList) != 0 and warnFlag is True:
        fmtStr = &#34;Collision warning for %s with items %s of tier %s&#34;
        print((fmtStr % (str(entry), str(matchList), self.name)))</code></pre>
</details>
</dd>
<dt id="praatio.tgio.PointTier.insertSpace"><code class="name flex">
<span>def <span class="ident">insertSpace</span></span>(<span>self, start, duration, collisionCode=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Inserts a region into the tier</p>
<p>collisionCode: Ignored for the moment (added for compatibility
with insertSpace() for Interval Tiers)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertSpace(self, start, duration, collisionCode=None):
    &#39;&#39;&#39;
    Inserts a region into the tier
    
    collisionCode: Ignored for the moment (added for compatibility
                   with insertSpace() for Interval Tiers)
    &#39;&#39;&#39;
    
    newEntryList = []
    for entry in self.entryList:
        if entry[0] &lt;= start:
            newEntryList.append(entry)
        elif entry[0] &gt; start:
            newEntryList.append((entry[0] + duration, entry[1]))
            
    newTier = self.new(entryList=newEntryList,
                       maxTimestamp=self.maxTimestamp + duration)
    
    return newTier</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="praatio.tgio.TextgridTier" href="#praatio.tgio.TextgridTier">TextgridTier</a></b></code>:
<ul class="hlist">
<li><code><a title="praatio.tgio.TextgridTier.appendTier" href="#praatio.tgio.TextgridTier.appendTier">appendTier</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.deleteEntry" href="#praatio.tgio.TextgridTier.deleteEntry">deleteEntry</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.find" href="#praatio.tgio.TextgridTier.find">find</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.getAsText" href="#praatio.tgio.TextgridTier.getAsText">getAsText</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.new" href="#praatio.tgio.TextgridTier.new">new</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.sort" href="#praatio.tgio.TextgridTier.sort">sort</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.union" href="#praatio.tgio.TextgridTier.union">union</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="praatio.tgio.Textgrid"><code class="flex name class">
<span>class <span class="ident">Textgrid</span></span>
</code></dt>
<dd>
<section class="desc"><p>A container that stores and operates over interval and point tiers</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Textgrid():
    
    def __init__(self):
        &#39;A container that stores and operates over interval and point tiers&#39;
        self.tierNameList = []  # Preserves the order of the tiers
        self.tierDict = {}
    
        self.minTimestamp = None
        self.maxTimestamp = None
    
    def __eq__(self, other):
        isEqual = True
        isEqual &amp;= _isclose(self.minTimestamp, other.minTimestamp)
        isEqual &amp;= _isclose(self.maxTimestamp, other.maxTimestamp)

        isEqual &amp;= self.tierNameList == other.tierNameList
        if isEqual:
            for tierName in self.tierNameList:
                isEqual &amp;= self.tierDict[tierName] == other.tierDict[tierName]
        
        return isEqual
    
    def addTier(self, tier, tierIndex=None):
        &#39;&#39;&#39;
        Add a tier to this textgrid.

        If tierIndex is specified, insert the tier into the specified position.
        &#39;&#39;&#39;
        
        assert(tier.name not in list(self.tierDict.keys()))

        if tierIndex is None:
            self.tierNameList.append(tier.name)
        else:
            self.tierNameList.insert(tierIndex, tier.name)
            
        self.tierDict[tier.name] = tier
        
        minV = tier.minTimestamp
        if self.minTimestamp is None or minV &lt; self.minTimestamp:
            self.minTimestamp = minV
        
        maxV = tier.maxTimestamp
        if self.maxTimestamp is None or maxV &gt; self.maxTimestamp:
            self.maxTimestamp = maxV
    
    def appendTextgrid(self, tg, onlyMatchingNames=True):
        &#39;&#39;&#39;
        Append one textgrid to the end of this one
        
        if onlyMatchingNames is False, tiers that don&#39;t appear in both
        textgrids will also appear
        &#39;&#39;&#39;
        retTG = Textgrid()
        
        minTime = self.minTimestamp
        maxTime = self.maxTimestamp + tg.maxTimestamp
        
        # Get all tier names.  Ordered first by this textgrid and
        # then by the other textgrid.
        combinedTierNameList = self.tierNameList
        for tierName in tg.tierNameList:
            if tierName not in combinedTierNameList:
                combinedTierNameList.append(tierName)
        
        # Determine the tier names that will be in the final textgrid
        finalTierNameList = []
        if onlyMatchingNames is False:
            finalTierNameList = combinedTierNameList
        else:
            for tierName in combinedTierNameList:
                if tierName in self.tierNameList:
                    if tierName in tg.tierNameList:
                        finalTierNameList.append(tierName)
        
        # Add tiers from this textgrid
        for tierName in self.tierNameList:
            if tierName in finalTierNameList:
                tier = self.tierDict[tierName]
                retTG.addTier(tier)
        
        # Add tiers from the given textgrid
        for tierName in tg.tierNameList:
            if tierName in finalTierNameList:
                appendTier = tg.tierDict[tierName]
                appendTier = appendTier.new(minTimestamp=minTime,
                                            maxTimestamp=maxTime)
                
                appendTier = appendTier.editTimestamps(self.maxTimestamp)
                
                if tierName in retTG.tierNameList:
                    tier = retTG.tierDict[tierName]
                    newEntryList = retTG.tierDict[tierName].entryList
                    newEntryList += appendTier.entryList
                    
                    tier = tier.new(entryList=newEntryList,
                                    minTimestamp=minTime,
                                    maxTimestamp=maxTime)
                    retTG.replaceTier(tierName, tier)
                    
                else:
                    tier = appendTier
                    tier = tier.new(minTimestamp=minTime,
                                    maxTimestamp=maxTime)
                    retTG.addTier(tier)
        
        return retTG

    def crop(self, cropStart, cropEnd, mode, rebaseToZero):
        &#39;&#39;&#39;
        Creates a textgrid where all intervals fit within the crop region
        
        mode = {&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;}
            If &#39;strict&#39;, only intervals wholly contained by the crop
                interval will be kept
            If &#39;lax&#39;, partially contained intervals will be kept
            If &#39;truncated&#39;, partially contained intervals will be
                truncated to fit within the crop region.
            
        If rebaseToZero is True, the cropped textgrid values will be
            subtracted by the cropStart
        &#39;&#39;&#39;
        
        assert(mode in [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;])
        
        newTG = Textgrid()
        
        if rebaseToZero is True:
            minT = 0
            maxT = cropEnd - cropStart
        else:
            minT = cropStart
            maxT = cropEnd
        newTG.minTimestamp = minT
        newTG.maxTimestamp = maxT
        for tierName in self.tierNameList:
            tier = self.tierDict[tierName]
            newTier = tier.crop(cropStart, cropEnd, mode, rebaseToZero)
            newTG.addTier(newTier)
        
        return newTG
    
    def eraseRegion(self, start, stop, doShrink=True):
        &#39;&#39;&#39;
        Makes a region in a tier blank (removes all contained entries)
        
        If &#39;doShrink&#39; is True, all entries appearing after the erased interval
        will be shifted to fill the void (ie the duration of the textgrid
        will be reduced by start - stop)
        &#39;&#39;&#39;

        diff = stop - start

        maxTimestamp = self.maxTimestamp
        if doShrink is True:
            maxTimestamp -= diff
            
        newTG = Textgrid()
        for name in self.tierNameList:
            tier = self.tierDict[name]
            tier = tier.eraseRegion(start, stop, &#39;truncate&#39;, doShrink)
            newTG.addTier(tier)

        newTG.maxTimestamp = maxTimestamp

        return newTG
            
    def editTimestamps(self, offset, allowOvershoot=False):
        &#39;&#39;&#39;
        Modifies all timestamps by a constant amount
        &#39;&#39;&#39;
        
        tg = Textgrid()
        for tierName in self.tierNameList:
            tier = self.tierDict[tierName]
            if len(tier.entryList) &gt; 0:
                tier = tier.editTimestamps(offset, allowOvershoot)
            
            tg.addTier(tier)
        
        return tg
    
    def insertSpace(self, start, duration, collisionCode=None):
        &#39;&#39;&#39;
        Inserts a blank region into a textgrid
        
        Every item that occurs after /start/ will be pushed back by
        /duration/ seconds
        
        collisionCode: in the event that an interval stradles the
                       starting point
        - &#39;stretch&#39; - stretches the interval by /duration/ amount
        - &#39;split&#39; - splits the interval into two--everything to the
                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds
        - &#39;no change&#39; - leaves the interval as is with no change
        - None or any other value - AssertionError is thrown
        &#39;&#39;&#39;
        
        newTG = Textgrid()
        newTG.minTimestamp = self.minTimestamp
        newTG.maxTimestamp = self.maxTimestamp + duration
        
        for tierName in self.tierNameList:
            tier = self.tierDict[tierName]
            newTier = tier.insertSpace(start, duration, collisionCode)
            newTG.addTier(newTier)
        
        return newTG

    def mergeTiers(self, includeFunc=None,
                   tierList=None, preserveOtherTiers=True):
        &#39;&#39;&#39;
        Combine tiers
        
        /includeFunc/ regulates which intervals to include in the merging
          with all others being tossed (default accepts all)
          
        If /tierList/ is none, combine all tiers.
        &#39;&#39;&#39;
        
        if tierList is None:
            tierList = self.tierNameList
            
        if includeFunc is None:
            includeFunc = lambda entryList: True
           
        # Determine the tiers to merge
        intervalTierNameList = []
        pointTierNameList = []
        for tierName in tierList:
            tier = self.tierDict[tierName]
            if isinstance(tier, IntervalTier):
                intervalTierNameList.append(tierName)
            elif isinstance(tier, PointTier):
                pointTierNameList.append(tierName)
        
        # Merge the interval tiers
        intervalTier = None
        if len(intervalTierNameList) &gt; 0:
            intervalTier = self.tierDict[intervalTierNameList.pop(0)]
        for tierName in intervalTierNameList:
            intervalTier = intervalTier.union(self.tierDict[tierName])

        # Merge the point tiers
        pointTier = None
        if len(pointTierNameList) &gt; 0:
            pointTier = self.tierDict[pointTierNameList.pop(0)]
        for tierName in pointTierNameList:
            pointTier = pointTier.merge(self.tierDict[tierName])
        
        # Create the final textgrid to output
        tg = Textgrid()
        
        if intervalTier is not None:
            tg.addTier(intervalTier)
        
        if pointTier is not None:
            tg.addTier(pointTier)
        
        return tg

    def new(self):
        &#39;&#39;&#39;Returns a copy of this Textgrid&#39;&#39;&#39;
        return copy.deepcopy(self)

    def renameTier(self, oldName, newName):
        oldTier = self.tierDict[oldName]
        tierIndex = self.tierNameList.index(oldName)
        self.removeTier(oldName)
        self.addTier(oldTier.new(newName, oldTier.entryList), tierIndex)
    
    def removeTier(self, name):
        self.tierNameList.pop(self.tierNameList.index(name))
        return self.tierDict.pop(name)

    def replaceTier(self, name, newTier):
        tierIndex = self.tierNameList.index(name)
        self.removeTier(name)
        self.addTier(newTier, tierIndex)

    def save(self, fn, minimumIntervalLength=MIN_INTERVAL_LENGTH, minTimestamp=None, maxTimestamp=None, useShortForm=True, outputFormat=TEXTGRID):
        &#39;&#39;&#39;
        To save the current textgrid

        fn - the fullpath filename of the output
        minimumIntervalLength - any labeled intervals smaller than this will be removed,
            useful for removing ultrashort or fragmented intervals; if None, don&#39;t remove any.
        minTimestamp - the minTimestamp of the saved Textgrid; if None, use whatever is defined
            in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid,
            an exception will be thrown.
        maxTimestamp - the maxTimestamp of the saved Textgrid; if None, use whatever is defined
            in the Textgrid object.  If maxTimestamp is smaller than timestamps in your textgrid,
            an exception will be thrown.
        useShortForm - if True, save the textgrid as a short textgrid. Otherwise, use the
            long-form textgrid format.  For backwards compatibility, is True by default.
            Ignored if format is not &#39;Textgrid&#39;
        format - one of [&#39;textgrid&#39;, &#39;json&#39;]
        &#39;&#39;&#39;

        if outputFormat not in SUPPORTED_OUTPUT_FORMATS:
            raise BadFormatException(outputFormat, SUPPORTED_OUTPUT_FORMATS)

        if outputFormat == TEXTGRID:
            if useShortForm:
                outputTxt = _tgToShortTextForm(
                    self,
                    minimumIntervalLength,
                    minTimestamp,
                    maxTimestamp)
            else:
                outputTxt = _tgToLongTextForm(
                    self,
                    minimumIntervalLength,
                    minTimestamp,
                    maxTimestamp)
        elif outputFormat == JSON:
            outputTxt = _tgToJson(self, minimumIntervalLength, minTimestamp, maxTimestamp)

        with io.open(fn, &#34;w&#34;, encoding=&#34;utf-8&#34;) as fd:
            fd.write(outputTxt)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="praatio.kgio.Klattgrid" href="kgio.html#praatio.kgio.Klattgrid">Klattgrid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="praatio.tgio.Textgrid.addTier"><code class="name flex">
<span>def <span class="ident">addTier</span></span>(<span>self, tier, tierIndex=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a tier to this textgrid.</p>
<p>If tierIndex is specified, insert the tier into the specified position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addTier(self, tier, tierIndex=None):
    &#39;&#39;&#39;
    Add a tier to this textgrid.

    If tierIndex is specified, insert the tier into the specified position.
    &#39;&#39;&#39;
    
    assert(tier.name not in list(self.tierDict.keys()))

    if tierIndex is None:
        self.tierNameList.append(tier.name)
    else:
        self.tierNameList.insert(tierIndex, tier.name)
        
    self.tierDict[tier.name] = tier
    
    minV = tier.minTimestamp
    if self.minTimestamp is None or minV &lt; self.minTimestamp:
        self.minTimestamp = minV
    
    maxV = tier.maxTimestamp
    if self.maxTimestamp is None or maxV &gt; self.maxTimestamp:
        self.maxTimestamp = maxV</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.appendTextgrid"><code class="name flex">
<span>def <span class="ident">appendTextgrid</span></span>(<span>self, tg, onlyMatchingNames=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Append one textgrid to the end of this one</p>
<p>if onlyMatchingNames is False, tiers that don't appear in both
textgrids will also appear</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appendTextgrid(self, tg, onlyMatchingNames=True):
    &#39;&#39;&#39;
    Append one textgrid to the end of this one
    
    if onlyMatchingNames is False, tiers that don&#39;t appear in both
    textgrids will also appear
    &#39;&#39;&#39;
    retTG = Textgrid()
    
    minTime = self.minTimestamp
    maxTime = self.maxTimestamp + tg.maxTimestamp
    
    # Get all tier names.  Ordered first by this textgrid and
    # then by the other textgrid.
    combinedTierNameList = self.tierNameList
    for tierName in tg.tierNameList:
        if tierName not in combinedTierNameList:
            combinedTierNameList.append(tierName)
    
    # Determine the tier names that will be in the final textgrid
    finalTierNameList = []
    if onlyMatchingNames is False:
        finalTierNameList = combinedTierNameList
    else:
        for tierName in combinedTierNameList:
            if tierName in self.tierNameList:
                if tierName in tg.tierNameList:
                    finalTierNameList.append(tierName)
    
    # Add tiers from this textgrid
    for tierName in self.tierNameList:
        if tierName in finalTierNameList:
            tier = self.tierDict[tierName]
            retTG.addTier(tier)
    
    # Add tiers from the given textgrid
    for tierName in tg.tierNameList:
        if tierName in finalTierNameList:
            appendTier = tg.tierDict[tierName]
            appendTier = appendTier.new(minTimestamp=minTime,
                                        maxTimestamp=maxTime)
            
            appendTier = appendTier.editTimestamps(self.maxTimestamp)
            
            if tierName in retTG.tierNameList:
                tier = retTG.tierDict[tierName]
                newEntryList = retTG.tierDict[tierName].entryList
                newEntryList += appendTier.entryList
                
                tier = tier.new(entryList=newEntryList,
                                minTimestamp=minTime,
                                maxTimestamp=maxTime)
                retTG.replaceTier(tierName, tier)
                
            else:
                tier = appendTier
                tier = tier.new(minTimestamp=minTime,
                                maxTimestamp=maxTime)
                retTG.addTier(tier)
    
    return retTG</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, cropStart, cropEnd, mode, rebaseToZero)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a textgrid where all intervals fit within the crop region</p>
<p>mode = {'strict', 'lax', 'truncated'}
If 'strict', only intervals wholly contained by the crop
interval will be kept
If 'lax', partially contained intervals will be kept
If 'truncated', partially contained intervals will be
truncated to fit within the crop region.</p>
<p>If rebaseToZero is True, the cropped textgrid values will be
subtracted by the cropStart</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop(self, cropStart, cropEnd, mode, rebaseToZero):
    &#39;&#39;&#39;
    Creates a textgrid where all intervals fit within the crop region
    
    mode = {&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;}
        If &#39;strict&#39;, only intervals wholly contained by the crop
            interval will be kept
        If &#39;lax&#39;, partially contained intervals will be kept
        If &#39;truncated&#39;, partially contained intervals will be
            truncated to fit within the crop region.
        
    If rebaseToZero is True, the cropped textgrid values will be
        subtracted by the cropStart
    &#39;&#39;&#39;
    
    assert(mode in [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;])
    
    newTG = Textgrid()
    
    if rebaseToZero is True:
        minT = 0
        maxT = cropEnd - cropStart
    else:
        minT = cropStart
        maxT = cropEnd
    newTG.minTimestamp = minT
    newTG.maxTimestamp = maxT
    for tierName in self.tierNameList:
        tier = self.tierDict[tierName]
        newTier = tier.crop(cropStart, cropEnd, mode, rebaseToZero)
        newTG.addTier(newTier)
    
    return newTG</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.editTimestamps"><code class="name flex">
<span>def <span class="ident">editTimestamps</span></span>(<span>self, offset, allowOvershoot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Modifies all timestamps by a constant amount</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editTimestamps(self, offset, allowOvershoot=False):
    &#39;&#39;&#39;
    Modifies all timestamps by a constant amount
    &#39;&#39;&#39;
    
    tg = Textgrid()
    for tierName in self.tierNameList:
        tier = self.tierDict[tierName]
        if len(tier.entryList) &gt; 0:
            tier = tier.editTimestamps(offset, allowOvershoot)
        
        tg.addTier(tier)
    
    return tg</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.eraseRegion"><code class="name flex">
<span>def <span class="ident">eraseRegion</span></span>(<span>self, start, stop, doShrink=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes a region in a tier blank (removes all contained entries)</p>
<p>If 'doShrink' is True, all entries appearing after the erased interval
will be shifted to fill the void (ie the duration of the textgrid
will be reduced by start - stop)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eraseRegion(self, start, stop, doShrink=True):
    &#39;&#39;&#39;
    Makes a region in a tier blank (removes all contained entries)
    
    If &#39;doShrink&#39; is True, all entries appearing after the erased interval
    will be shifted to fill the void (ie the duration of the textgrid
    will be reduced by start - stop)
    &#39;&#39;&#39;

    diff = stop - start

    maxTimestamp = self.maxTimestamp
    if doShrink is True:
        maxTimestamp -= diff
        
    newTG = Textgrid()
    for name in self.tierNameList:
        tier = self.tierDict[name]
        tier = tier.eraseRegion(start, stop, &#39;truncate&#39;, doShrink)
        newTG.addTier(tier)

    newTG.maxTimestamp = maxTimestamp

    return newTG</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.insertSpace"><code class="name flex">
<span>def <span class="ident">insertSpace</span></span>(<span>self, start, duration, collisionCode=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Inserts a blank region into a textgrid</p>
<p>Every item that occurs after /start/ will be pushed back by
/duration/ seconds</p>
<p>collisionCode: in the event that an interval stradles the
starting point
- 'stretch' - stretches the interval by /duration/ amount
- 'split' - splits the interval into two&ndash;everything to the
right of 'start' will be advanced by 'duration' seconds
- 'no change' - leaves the interval as is with no change
- None or any other value - AssertionError is thrown</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertSpace(self, start, duration, collisionCode=None):
    &#39;&#39;&#39;
    Inserts a blank region into a textgrid
    
    Every item that occurs after /start/ will be pushed back by
    /duration/ seconds
    
    collisionCode: in the event that an interval stradles the
                   starting point
    - &#39;stretch&#39; - stretches the interval by /duration/ amount
    - &#39;split&#39; - splits the interval into two--everything to the
                right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds
    - &#39;no change&#39; - leaves the interval as is with no change
    - None or any other value - AssertionError is thrown
    &#39;&#39;&#39;
    
    newTG = Textgrid()
    newTG.minTimestamp = self.minTimestamp
    newTG.maxTimestamp = self.maxTimestamp + duration
    
    for tierName in self.tierNameList:
        tier = self.tierDict[tierName]
        newTier = tier.insertSpace(start, duration, collisionCode)
        newTG.addTier(newTier)
    
    return newTG</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.mergeTiers"><code class="name flex">
<span>def <span class="ident">mergeTiers</span></span>(<span>self, includeFunc=None, tierList=None, preserveOtherTiers=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Combine tiers</p>
<p>/includeFunc/ regulates which intervals to include in the merging
with all others being tossed (default accepts all)</p>
<p>If /tierList/ is none, combine all tiers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeTiers(self, includeFunc=None,
               tierList=None, preserveOtherTiers=True):
    &#39;&#39;&#39;
    Combine tiers
    
    /includeFunc/ regulates which intervals to include in the merging
      with all others being tossed (default accepts all)
      
    If /tierList/ is none, combine all tiers.
    &#39;&#39;&#39;
    
    if tierList is None:
        tierList = self.tierNameList
        
    if includeFunc is None:
        includeFunc = lambda entryList: True
       
    # Determine the tiers to merge
    intervalTierNameList = []
    pointTierNameList = []
    for tierName in tierList:
        tier = self.tierDict[tierName]
        if isinstance(tier, IntervalTier):
            intervalTierNameList.append(tierName)
        elif isinstance(tier, PointTier):
            pointTierNameList.append(tierName)
    
    # Merge the interval tiers
    intervalTier = None
    if len(intervalTierNameList) &gt; 0:
        intervalTier = self.tierDict[intervalTierNameList.pop(0)]
    for tierName in intervalTierNameList:
        intervalTier = intervalTier.union(self.tierDict[tierName])

    # Merge the point tiers
    pointTier = None
    if len(pointTierNameList) &gt; 0:
        pointTier = self.tierDict[pointTierNameList.pop(0)]
    for tierName in pointTierNameList:
        pointTier = pointTier.merge(self.tierDict[tierName])
    
    # Create the final textgrid to output
    tg = Textgrid()
    
    if intervalTier is not None:
        tg.addTier(intervalTier)
    
    if pointTier is not None:
        tg.addTier(pointTier)
    
    return tg</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a copy of this Textgrid</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(self):
    &#39;&#39;&#39;Returns a copy of this Textgrid&#39;&#39;&#39;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.removeTier"><code class="name flex">
<span>def <span class="ident">removeTier</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeTier(self, name):
    self.tierNameList.pop(self.tierNameList.index(name))
    return self.tierDict.pop(name)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.renameTier"><code class="name flex">
<span>def <span class="ident">renameTier</span></span>(<span>self, oldName, newName)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renameTier(self, oldName, newName):
    oldTier = self.tierDict[oldName]
    tierIndex = self.tierNameList.index(oldName)
    self.removeTier(oldName)
    self.addTier(oldTier.new(newName, oldTier.entryList), tierIndex)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.replaceTier"><code class="name flex">
<span>def <span class="ident">replaceTier</span></span>(<span>self, name, newTier)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replaceTier(self, name, newTier):
    tierIndex = self.tierNameList.index(name)
    self.removeTier(name)
    self.addTier(newTier, tierIndex)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.Textgrid.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, fn, minimumIntervalLength=1e-08, minTimestamp=None, maxTimestamp=None, useShortForm=True, outputFormat='textgrid')</span>
</code></dt>
<dd>
<section class="desc"><p>To save the current textgrid</p>
<p>fn - the fullpath filename of the output
minimumIntervalLength - any labeled intervals smaller than this will be removed,
useful for removing ultrashort or fragmented intervals; if None, don't remove any.
minTimestamp - the minTimestamp of the saved Textgrid; if None, use whatever is defined
in the Textgrid object.
If minTimestamp is larger than timestamps in your textgrid,
an exception will be thrown.
maxTimestamp - the maxTimestamp of the saved Textgrid; if None, use whatever is defined
in the Textgrid object.
If maxTimestamp is smaller than timestamps in your textgrid,
an exception will be thrown.
useShortForm - if True, save the textgrid as a short textgrid. Otherwise, use the
long-form textgrid format.
For backwards compatibility, is True by default.
Ignored if format is not 'Textgrid'
format - one of ['textgrid', 'json']</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, fn, minimumIntervalLength=MIN_INTERVAL_LENGTH, minTimestamp=None, maxTimestamp=None, useShortForm=True, outputFormat=TEXTGRID):
    &#39;&#39;&#39;
    To save the current textgrid

    fn - the fullpath filename of the output
    minimumIntervalLength - any labeled intervals smaller than this will be removed,
        useful for removing ultrashort or fragmented intervals; if None, don&#39;t remove any.
    minTimestamp - the minTimestamp of the saved Textgrid; if None, use whatever is defined
        in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid,
        an exception will be thrown.
    maxTimestamp - the maxTimestamp of the saved Textgrid; if None, use whatever is defined
        in the Textgrid object.  If maxTimestamp is smaller than timestamps in your textgrid,
        an exception will be thrown.
    useShortForm - if True, save the textgrid as a short textgrid. Otherwise, use the
        long-form textgrid format.  For backwards compatibility, is True by default.
        Ignored if format is not &#39;Textgrid&#39;
    format - one of [&#39;textgrid&#39;, &#39;json&#39;]
    &#39;&#39;&#39;

    if outputFormat not in SUPPORTED_OUTPUT_FORMATS:
        raise BadFormatException(outputFormat, SUPPORTED_OUTPUT_FORMATS)

    if outputFormat == TEXTGRID:
        if useShortForm:
            outputTxt = _tgToShortTextForm(
                self,
                minimumIntervalLength,
                minTimestamp,
                maxTimestamp)
        else:
            outputTxt = _tgToLongTextForm(
                self,
                minimumIntervalLength,
                minTimestamp,
                maxTimestamp)
    elif outputFormat == JSON:
        outputTxt = _tgToJson(self, minimumIntervalLength, minTimestamp, maxTimestamp)

    with io.open(fn, &#34;w&#34;, encoding=&#34;utf-8&#34;) as fd:
        fd.write(outputTxt)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="praatio.tgio.TextgridCollisionException"><code class="flex name class">
<span>class <span class="ident">TextgridCollisionException</span></span>
<span>(</span><span>tierName, insertInterval, collisionList)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextgridCollisionException(Exception):
    
    def __init__(self, tierName, insertInterval, collisionList):
        super(TextgridCollisionException, self).__init__()
        self.tierName = tierName
        self.insertInterval = insertInterval
        self.collisionList = collisionList
        
    def __str__(self):
        dataTuple = (str(self.insertInterval),
                     self.tierName,
                     str(self.collisionList))
        return (&#34;Attempted to insert interval %s into tier %s of textgrid&#34; +
                &#34;but overlapping entries %s already exist&#34; % dataTuple)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="praatio.tgio.TextgridTier"><code class="flex name class">
<span>class <span class="ident">TextgridTier</span></span>
<span>(</span><span>name, entryList, minT, maxT, pairedWav=None)</span>
</code></dt>
<dd>
<section class="desc"><p>See PointTier or IntervalTier</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextgridTier(object):
    
    tierType = None
    entryType = Interval
    
    def __init__(self, name, entryList, minT, maxT,
                 pairedWav=None):
        &#39;&#39;&#39;See PointTier or IntervalTier&#39;&#39;&#39;
        entryList.sort()
        
        self.name = name
        self.entryList = entryList
        self.minTimestamp = minT
        self.maxTimestamp = maxT
    
    def __eq__(self, other):
        isEqual = True
        isEqual &amp;= self.name == other.name
        isEqual &amp;= _isclose(self.minTimestamp, other.minTimestamp)
        isEqual &amp;= _isclose(self.maxTimestamp, other.maxTimestamp)
        isEqual &amp;= len(self.entryList) == len(self.entryList)
        
        if isEqual:
            for selfEntry, otherEntry in zip(self.entryList, other.entryList):
                for selfSubEntry, otherSubEntry in zip(selfEntry, otherEntry):
                    try:
                        isEqual &amp;= _isclose(selfSubEntry, otherSubEntry)
                    except TypeError:
                        isEqual &amp;= selfSubEntry == otherSubEntry
        
        return isEqual
    
    def appendTier(self, tier):
        &#39;&#39;&#39;
        Append a tier to the end of this one.

        This tier&#39;s maxtimestamp will be lengthened by the amount in the passed in tier.
        &#39;&#39;&#39;

        minTime = self.minTimestamp
        if tier.minTimestamp &lt; minTime:
            minTime = tier.minTimestamp
        
        maxTime = self.maxTimestamp + tier.maxTimestamp
        
        appendTier = tier.editTimestamps(self.maxTimestamp,
                                         allowOvershoot=True)
        
        assert(self.tierType == tier.tierType)
        
        entryList = self.entryList + appendTier.entryList
        entryList.sort()
        
        return self.new(self.name,
                        entryList,
                        minTimestamp=minTime,
                        maxTimestamp=maxTime)

    def deleteEntry(self, entry):
        &#39;&#39;&#39;Removes an entry from the entryList&#39;&#39;&#39;
        self.entryList.pop(self.entryList.index(entry))
    
    def find(self, matchLabel, substrMatchFlag=False, usingRE=False):
        &#39;&#39;&#39;
        Returns the index of all intervals that match the given label
        
        substrMatchFlag: if True, match any label containing matchLabel.
                         if False, label must be the same as matchLabel.
        usingRE: if True, matchLabel is interpreted as a regular expression
        &#39;&#39;&#39;
        returnList = []
        if usingRE is True:
            for i, entry in enumerate(self.entryList):
                matchList = re.findall(matchLabel, entry[-1], re.I)
                if matchList != []:
                    returnList.append(i)
        else:
            for i, entry in enumerate(self.entryList):
                if not substrMatchFlag:
                    if entry[-1] == matchLabel:
                        returnList.append(i)
                else:
                    if matchLabel in entry[-1]:
                        returnList.append(i)
        
        return returnList
    
    def getAsText(self):
        &#39;&#39;&#39;Prints each entry in the tier on a separate line w/ timing info&#39;&#39;&#39;
        text = &#34;&#34;
        text += &#39;&#34;%s&#34;\n&#39; % self.tierType
        text += &#39;&#34;%s&#34;\n&#39; % self.name
        text += &#39;%s\n%s\n%s\n&#39; % (numToStr(self.minTimestamp),
                                  numToStr(self.maxTimestamp),
                                  len(self.entryList))
        
        for entry in self.entryList:
            entry = [numToStr(val) for val in entry[:-1]] + [&#39;&#34;%s&#34;&#39; % entry[-1], ]
            try:
                unicode
            except NameError:
                unicodeFunc = str
            else:
                unicodeFunc = unicode
            
            text += &#34;\n&#34;.join([unicodeFunc(val) for val in entry]) + &#34;\n&#34;
            
        return text
    
    def new(self, name=None, entryList=None, minTimestamp=None,
            maxTimestamp=None, pairedWav=None):
        &#39;&#39;&#39;Make a new tier derived from the current one&#39;&#39;&#39;
        if name is None:
            name = self.name
        if entryList is None:
            entryList = copy.deepcopy(self.entryList)
            entryList = [self.entryType(*entry) if isinstance(entry, tuple)
                         else entry
                         for entry in entryList]
        if minTimestamp is None:
            minTimestamp = self.minTimestamp
        if maxTimestamp is None and pairedWav is None:
            maxTimestamp = self.maxTimestamp
        return type(self)(name, entryList, minTimestamp, maxTimestamp,
                          pairedWav)
    
    def sort(self):
        &#39;&#39;&#39;Sorts the entries in the entryList&#39;&#39;&#39;
        # A list containing tuples and lists will be sorted with tuples
        # first and then lists.  To correctly sort, we need to make
        # sure that all data structures inside the entry list are
        # of the same data type.  The entry list is sorted whenever
        # the entry list is modified, so this is probably the best
        # place to enforce the data type
        self.entryList = [entry if isinstance(entry, self.entryType) else
                          self.entryType(*entry) for entry in self.entryList]
        self.entryList.sort()
        
    def union(self, tier):
        &#39;&#39;&#39;
        The given tier is set unioned to this tier.
        
        All entries in the given tier are added to the current tier.
        Overlapping entries are merged.
        &#39;&#39;&#39;
        retTier = self.new()
        
        for entry in tier.entryList:
            retTier.insertEntry(entry, False, collisionCode=&#39;merge&#39;)
        
        retTier.sort()
        
        return retTier</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="praatio.kgio.KlattPointTier" href="kgio.html#praatio.kgio.KlattPointTier">KlattPointTier</a></li>
<li><a title="praatio.tgio.IntervalTier" href="#praatio.tgio.IntervalTier">IntervalTier</a></li>
<li><a title="praatio.tgio.PointTier" href="#praatio.tgio.PointTier">PointTier</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="praatio.tgio.TextgridTier.entryType"><code class="name">var <span class="ident">entryType</span></code></dt>
<dd>
<section class="desc"><p>Interval(start, end, label)</p></section>
</dd>
<dt id="praatio.tgio.TextgridTier.tierType"><code class="name">var <span class="ident">tierType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="praatio.tgio.TextgridTier.appendTier"><code class="name flex">
<span>def <span class="ident">appendTier</span></span>(<span>self, tier)</span>
</code></dt>
<dd>
<section class="desc"><p>Append a tier to the end of this one.</p>
<p>This tier's maxtimestamp will be lengthened by the amount in the passed in tier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appendTier(self, tier):
    &#39;&#39;&#39;
    Append a tier to the end of this one.

    This tier&#39;s maxtimestamp will be lengthened by the amount in the passed in tier.
    &#39;&#39;&#39;

    minTime = self.minTimestamp
    if tier.minTimestamp &lt; minTime:
        minTime = tier.minTimestamp
    
    maxTime = self.maxTimestamp + tier.maxTimestamp
    
    appendTier = tier.editTimestamps(self.maxTimestamp,
                                     allowOvershoot=True)
    
    assert(self.tierType == tier.tierType)
    
    entryList = self.entryList + appendTier.entryList
    entryList.sort()
    
    return self.new(self.name,
                    entryList,
                    minTimestamp=minTime,
                    maxTimestamp=maxTime)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.TextgridTier.deleteEntry"><code class="name flex">
<span>def <span class="ident">deleteEntry</span></span>(<span>self, entry)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes an entry from the entryList</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteEntry(self, entry):
    &#39;&#39;&#39;Removes an entry from the entryList&#39;&#39;&#39;
    self.entryList.pop(self.entryList.index(entry))</code></pre>
</details>
</dd>
<dt id="praatio.tgio.TextgridTier.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, matchLabel, substrMatchFlag=False, usingRE=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the index of all intervals that match the given label</p>
<p>substrMatchFlag: if True, match any label containing matchLabel.
if False, label must be the same as matchLabel.
usingRE: if True, matchLabel is interpreted as a regular expression</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, matchLabel, substrMatchFlag=False, usingRE=False):
    &#39;&#39;&#39;
    Returns the index of all intervals that match the given label
    
    substrMatchFlag: if True, match any label containing matchLabel.
                     if False, label must be the same as matchLabel.
    usingRE: if True, matchLabel is interpreted as a regular expression
    &#39;&#39;&#39;
    returnList = []
    if usingRE is True:
        for i, entry in enumerate(self.entryList):
            matchList = re.findall(matchLabel, entry[-1], re.I)
            if matchList != []:
                returnList.append(i)
    else:
        for i, entry in enumerate(self.entryList):
            if not substrMatchFlag:
                if entry[-1] == matchLabel:
                    returnList.append(i)
            else:
                if matchLabel in entry[-1]:
                    returnList.append(i)
    
    return returnList</code></pre>
</details>
</dd>
<dt id="praatio.tgio.TextgridTier.getAsText"><code class="name flex">
<span>def <span class="ident">getAsText</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints each entry in the tier on a separate line w/ timing info</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAsText(self):
    &#39;&#39;&#39;Prints each entry in the tier on a separate line w/ timing info&#39;&#39;&#39;
    text = &#34;&#34;
    text += &#39;&#34;%s&#34;\n&#39; % self.tierType
    text += &#39;&#34;%s&#34;\n&#39; % self.name
    text += &#39;%s\n%s\n%s\n&#39; % (numToStr(self.minTimestamp),
                              numToStr(self.maxTimestamp),
                              len(self.entryList))
    
    for entry in self.entryList:
        entry = [numToStr(val) for val in entry[:-1]] + [&#39;&#34;%s&#34;&#39; % entry[-1], ]
        try:
            unicode
        except NameError:
            unicodeFunc = str
        else:
            unicodeFunc = unicode
        
        text += &#34;\n&#34;.join([unicodeFunc(val) for val in entry]) + &#34;\n&#34;
        
    return text</code></pre>
</details>
</dd>
<dt id="praatio.tgio.TextgridTier.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, name=None, entryList=None, minTimestamp=None, maxTimestamp=None, pairedWav=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Make a new tier derived from the current one</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(self, name=None, entryList=None, minTimestamp=None,
        maxTimestamp=None, pairedWav=None):
    &#39;&#39;&#39;Make a new tier derived from the current one&#39;&#39;&#39;
    if name is None:
        name = self.name
    if entryList is None:
        entryList = copy.deepcopy(self.entryList)
        entryList = [self.entryType(*entry) if isinstance(entry, tuple)
                     else entry
                     for entry in entryList]
    if minTimestamp is None:
        minTimestamp = self.minTimestamp
    if maxTimestamp is None and pairedWav is None:
        maxTimestamp = self.maxTimestamp
    return type(self)(name, entryList, minTimestamp, maxTimestamp,
                      pairedWav)</code></pre>
</details>
</dd>
<dt id="praatio.tgio.TextgridTier.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Sorts the entries in the entryList</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self):
    &#39;&#39;&#39;Sorts the entries in the entryList&#39;&#39;&#39;
    # A list containing tuples and lists will be sorted with tuples
    # first and then lists.  To correctly sort, we need to make
    # sure that all data structures inside the entry list are
    # of the same data type.  The entry list is sorted whenever
    # the entry list is modified, so this is probably the best
    # place to enforce the data type
    self.entryList = [entry if isinstance(entry, self.entryType) else
                      self.entryType(*entry) for entry in self.entryList]
    self.entryList.sort()</code></pre>
</details>
</dd>
<dt id="praatio.tgio.TextgridTier.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, tier)</span>
</code></dt>
<dd>
<section class="desc"><p>The given tier is set unioned to this tier.</p>
<p>All entries in the given tier are added to the current tier.
Overlapping entries are merged.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, tier):
    &#39;&#39;&#39;
    The given tier is set unioned to this tier.
    
    All entries in the given tier are added to the current tier.
    Overlapping entries are merged.
    &#39;&#39;&#39;
    retTier = self.new()
    
    for entry in tier.entryList:
        retTier.insertEntry(entry, False, collisionCode=&#39;merge&#39;)
    
    retTier.sort()
    
    return retTier</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="praatio.tgio.TimelessTextgridTierException"><code class="flex name class">
<span>class <span class="ident">TimelessTextgridTierException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimelessTextgridTierException(Exception):
    
    def __str__(self):
        return &#34;All textgrid tiers much have a min and max duration&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="praatio" href="index.html">praatio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="praatio.tgio.intervalOverlapCheck" href="#praatio.tgio.intervalOverlapCheck">intervalOverlapCheck</a></code></li>
<li><code><a title="praatio.tgio.numToStr" href="#praatio.tgio.numToStr">numToStr</a></code></li>
<li><code><a title="praatio.tgio.openTextgrid" href="#praatio.tgio.openTextgrid">openTextgrid</a></code></li>
<li><code><a title="praatio.tgio.strToIntOrFloat" href="#praatio.tgio.strToIntOrFloat">strToIntOrFloat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="praatio.tgio.BadFormatException" href="#praatio.tgio.BadFormatException">BadFormatException</a></code></h4>
</li>
<li>
<h4><code><a title="praatio.tgio.BadIntervalError" href="#praatio.tgio.BadIntervalError">BadIntervalError</a></code></h4>
</li>
<li>
<h4><code><a title="praatio.tgio.Interval" href="#praatio.tgio.Interval">Interval</a></code></h4>
<ul class="">
<li><code><a title="praatio.tgio.Interval.end" href="#praatio.tgio.Interval.end">end</a></code></li>
<li><code><a title="praatio.tgio.Interval.label" href="#praatio.tgio.Interval.label">label</a></code></li>
<li><code><a title="praatio.tgio.Interval.start" href="#praatio.tgio.Interval.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="praatio.tgio.IntervalTier" href="#praatio.tgio.IntervalTier">IntervalTier</a></code></h4>
<ul class="">
<li><code><a title="praatio.tgio.IntervalTier.crop" href="#praatio.tgio.IntervalTier.crop">crop</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.difference" href="#praatio.tgio.IntervalTier.difference">difference</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.editTimestamps" href="#praatio.tgio.IntervalTier.editTimestamps">editTimestamps</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.eraseRegion" href="#praatio.tgio.IntervalTier.eraseRegion">eraseRegion</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.getNonEntries" href="#praatio.tgio.IntervalTier.getNonEntries">getNonEntries</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.getValuesInIntervals" href="#praatio.tgio.IntervalTier.getValuesInIntervals">getValuesInIntervals</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.insertEntry" href="#praatio.tgio.IntervalTier.insertEntry">insertEntry</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.insertSpace" href="#praatio.tgio.IntervalTier.insertSpace">insertSpace</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.intersection" href="#praatio.tgio.IntervalTier.intersection">intersection</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.morph" href="#praatio.tgio.IntervalTier.morph">morph</a></code></li>
<li><code><a title="praatio.tgio.IntervalTier.tierType" href="#praatio.tgio.IntervalTier.tierType">tierType</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="praatio.tgio.Point" href="#praatio.tgio.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="praatio.tgio.Point.label" href="#praatio.tgio.Point.label">label</a></code></li>
<li><code><a title="praatio.tgio.Point.time" href="#praatio.tgio.Point.time">time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="praatio.tgio.PointTier" href="#praatio.tgio.PointTier">PointTier</a></code></h4>
<ul class="two-column">
<li><code><a title="praatio.tgio.PointTier.crop" href="#praatio.tgio.PointTier.crop">crop</a></code></li>
<li><code><a title="praatio.tgio.PointTier.editTimestamps" href="#praatio.tgio.PointTier.editTimestamps">editTimestamps</a></code></li>
<li><code><a title="praatio.tgio.PointTier.entryType" href="#praatio.tgio.PointTier.entryType">entryType</a></code></li>
<li><code><a title="praatio.tgio.PointTier.eraseRegion" href="#praatio.tgio.PointTier.eraseRegion">eraseRegion</a></code></li>
<li><code><a title="praatio.tgio.PointTier.getValuesAtPoints" href="#praatio.tgio.PointTier.getValuesAtPoints">getValuesAtPoints</a></code></li>
<li><code><a title="praatio.tgio.PointTier.insertEntry" href="#praatio.tgio.PointTier.insertEntry">insertEntry</a></code></li>
<li><code><a title="praatio.tgio.PointTier.insertSpace" href="#praatio.tgio.PointTier.insertSpace">insertSpace</a></code></li>
<li><code><a title="praatio.tgio.PointTier.tierType" href="#praatio.tgio.PointTier.tierType">tierType</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="praatio.tgio.Textgrid" href="#praatio.tgio.Textgrid">Textgrid</a></code></h4>
<ul class="two-column">
<li><code><a title="praatio.tgio.Textgrid.addTier" href="#praatio.tgio.Textgrid.addTier">addTier</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.appendTextgrid" href="#praatio.tgio.Textgrid.appendTextgrid">appendTextgrid</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.crop" href="#praatio.tgio.Textgrid.crop">crop</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.editTimestamps" href="#praatio.tgio.Textgrid.editTimestamps">editTimestamps</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.eraseRegion" href="#praatio.tgio.Textgrid.eraseRegion">eraseRegion</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.insertSpace" href="#praatio.tgio.Textgrid.insertSpace">insertSpace</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.mergeTiers" href="#praatio.tgio.Textgrid.mergeTiers">mergeTiers</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.new" href="#praatio.tgio.Textgrid.new">new</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.removeTier" href="#praatio.tgio.Textgrid.removeTier">removeTier</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.renameTier" href="#praatio.tgio.Textgrid.renameTier">renameTier</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.replaceTier" href="#praatio.tgio.Textgrid.replaceTier">replaceTier</a></code></li>
<li><code><a title="praatio.tgio.Textgrid.save" href="#praatio.tgio.Textgrid.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="praatio.tgio.TextgridCollisionException" href="#praatio.tgio.TextgridCollisionException">TextgridCollisionException</a></code></h4>
</li>
<li>
<h4><code><a title="praatio.tgio.TextgridTier" href="#praatio.tgio.TextgridTier">TextgridTier</a></code></h4>
<ul class="two-column">
<li><code><a title="praatio.tgio.TextgridTier.appendTier" href="#praatio.tgio.TextgridTier.appendTier">appendTier</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.deleteEntry" href="#praatio.tgio.TextgridTier.deleteEntry">deleteEntry</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.entryType" href="#praatio.tgio.TextgridTier.entryType">entryType</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.find" href="#praatio.tgio.TextgridTier.find">find</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.getAsText" href="#praatio.tgio.TextgridTier.getAsText">getAsText</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.new" href="#praatio.tgio.TextgridTier.new">new</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.sort" href="#praatio.tgio.TextgridTier.sort">sort</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.tierType" href="#praatio.tgio.TextgridTier.tierType">tierType</a></code></li>
<li><code><a title="praatio.tgio.TextgridTier.union" href="#praatio.tgio.TextgridTier.union">union</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="praatio.tgio.TimelessTextgridTierException" href="#praatio.tgio.TimelessTextgridTierException">TimelessTextgridTierException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>